## 执行上下文与执行栈

### 什么是执行上下文

**总结**
* 执行上下文是评估和执行JS代码的环境的抽象概念，JS代码就是在执行上下文中执行的
* 执行上下文携带了执行JS代码所需的信息，包括：变量，函数声明，参数arguemnts，作用域链和this指向等信息
### 执行上下文的类型

#### 全局执行上下文 GEC (Global Execute Context)

>这是默认或者说基础的上下文，`任何不在函数内部的代码`都在全局上下文中

**执行**
它会执行两件事：
* 创建一个全局的 window 对象（浏览器的情况下）
* 并且设置 `this` 的值等于这个全局对象

**一个程序中只会有一个全局执行上下文**

#### 函数执行上下文 FEC (Function Execute Context)

>每当一个函数被调用时, 都会为该函数创建一个新的上下文

**创建时机**
* 每个函数都有它自己的执行上下文，不过是在函数`被调用时创建`的
* 函数上下文可以有任意多个

**执行**
* 每当一个新的执行上下文被创建，它会按定义的顺序（将在后文讨论）执行一系列步骤

#### Eval函数执行上下文

>  执行在 `eval` 函数内部的代码也会有它属于自己的执行上下文

* `eval` 可以**运行时动态修改**当前作用域，而普通 JS 代码的作用域是静态（词法）确定的

### 执行上下文生命周期

- **创建阶段**  
   * ES5之前：生成全局对象GO和变量对象VO
     * `创建arguments`
     * `扫描函数声明`
     * `扫描var变量声明`
   * ES5之后：创建词法环境组件/变量环境组件
   * 建立作用域
   * 确定this的指向

- **执行阶段**
   * 变量赋值
   * 函数的引用
   * 执行其他代码

* **销毁阶段**
   * 执行完毕出栈
   * 闭包变量被保留（如被引用）
   * 其他变量等待GC回收
### 执行栈

> 执行栈，也就是在其它编程语言中所说的`调用栈`
> 是一种拥有 LIFO（后进先出）数据结构的栈
> 被用来存储管理代码运行时创建的所有`执行上下文`

1）当 JS 引擎第一次遇到js脚本时，会创建一个全局的执行上下文并且压入当前执行栈
2）每当 JS 引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部
3）当该函数执行结束时，函数执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文
4）一旦所有代码执行完毕，JS 引擎从当前栈中移除全局执行上下文

```js
var a = 1; // 1. 全局上下文环境
function bar (x) {
    console.log('bar')
    var b = 2;
    fn(x + b); // 3. fn上下文环境
}
function fn (c) {
    console.log(c);
}
bar(3); // 2. bar上下文环境

```

### 创建执行上下文的过程

> 创建执行上下文有两个阶段：**1) 创建阶段** 和 **2) 执行阶段**。

#### 创建阶段 即代码运行前的解析阶段

**创建阶段会发生的事情：**
1. **this** 值的决定，即我们所熟知的 **This 绑定**。
2. 创建**词法环境**组件。
3. 创建**变量环境**组件。

这一阶段的核心行为是**处理声明（变量和函数）**，但不会执行任何赋值或逻辑代码

##### This绑定

**普通函数的四条绑定规则**
* 默认绑定 -- 全局运行的函数
* 隐式绑定 -- 对象调用的函数
* 显示绑定 -- apply,bind,call函数显式为this赋值
* new绑定 -- 作为构造函数使用new关键字调用

**箭头函数的this指向**
* 对于箭头函数，它本身是没有this属性的
* 如果我们在函数内部调用this，它则会执行该箭头函数的上一层作用域的this
##### 词法环境

**官方的ES6文档将词法环境定义为：**

**词法环境**是一种规范类型，基于 ECMAScript 代码的词法嵌套结构来`定义标识符和 具体变量和函数 的关联`
一个词法环境由 `环境记录器`和一个`可能的`引用**外部**词法环境组成。
###### 词法环境的概念
**简单来说：**
* 词法环境是一种持有`标识符—变量` `映射`的结构，用于定义它们的关联
     * **标识符**指的是变量/函数的名字
     * **变量**是对实际对象 (`包含函数类型对象`) 或原始数据的引用
###### 词法环境的组件

现在，在词法环境的**内部**有两个组件：(1) **环境记录器**和 (2) 一个**外部环境的引用**

1. **环境记录器**是存储变量和函数声明的`实际位置`
2. **外部环境的引用**意味着它可以访问其`父级`词法环境（作用域）

###### 词法环境的类型

* **全局环境**（在全局执行上下文中）是`没有外部环境引用`的词法环境
     * 全局环境的外部环境引用是 **null ** 
     * 它拥有内建的 `Object/Array/` 等
     * 在环境记录器内：有原型函数（关联全局对象，比如 window 对象）还有任何用户定义的全局变量，并且 `this`的值指向全局对象

- **函数环境**
     * 函数内部用户定义的变量存储在环境记录器中
     * 引用的外部环境可能是全局环境，或者任何包含此内部函数的外部函数

###### 环境记录器的类型

1. **声明式环境记录器** -- 存储变量、函数和参数。
2. **对象环境记录器** -- 用来定义出现在`全局上下文`中的`变量和函数的关系`

- 在**全局环境**中，环境记录器是对象环境记录器
- 在**函数环境**中，环境记录器是声明式环境记录器

##### 变量环境

它同样是一个词法环境，其环境记录器持有**变量声明语句**在执行上下文中创建的绑定关系
所以它也有着上面定义的词法环境的所有属性

**变量环境和词法环境的区别：**
* 词法环境被用来存储函数声明和变量（`let` 和 `const`）绑定
* 变量环境只用来存储 `var` 变量绑定。

#### 执行阶段 即代码的正式运行阶段

> 在此阶段，完成对所有这些变量的分配，最后执行代码。


### 执行上下文的特点

1）单线程，只在主线程上运行；
2）同步执行，从上向下按顺序执行；
3）全局上下文只有一个，也就是`window`对象；
4）函数每调用一次就会产生一个新的函数执行上下文

## 作用域和作用域链

### 什么是作用域

作用域：可访问变量的集合
作用域最大的用处就是`隔离变量`，不同作用域下同名变量不会有冲突

作用域可以看做是一套设计良好的规则，用于规定如何正确存储和访问变量

### 作用域类型

* ES5之前：全局作用域和函数作用域
* ES6新增：块级作用域

#### 函数作用域

是指声明在函数内部的变量，函数的作用域在函数定义的时候就决定了

```js
function foo(){
  // 这里就是一个函数作用域
}

// 这里是全局作用域
```
#### 块作用域

1）块作用域由`{ }`包括，if和for语句里面的`{ }`也属于块作用域  
2）在块级作用域中，可通过`let和const声明`变量，该变量在指定块的作用域外无法被访问


### var,let和const的区别

* **var**定义的变量没有块的概念，可以跨块访问，可以变量提升
* **let**定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问，无变量提升，不可以重复声明
* **const**用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改，无变量提升，不可以重复声明

### 作用域链

当查找变量的时候，会先从`当前上下文的变量对象`中查找，如果没有找到，就会从`父级(词法层面上的父级)执行上下文`的变量对象中查找
一直找到`全局上下文`的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。

**执行上下文和作用域链的关系**
执行上下文的创建阶段会`建立作用域链`，而作用域链的构成正是基于`词法作用域`（即代码的嵌套结构）

## 事件循环event loop

**Event Loop是javascript的执行机制；也是实现异步的一种方式**

**如何理解上述概括**
* JavaScript 只有一个主线程，无法像多线程语言那样并发执行任务。Event Loop 通过 **“非阻塞监听+队列调度”** 模拟了异步效果。

**知识总结**
* JS是一门单线程语言，为了避免队列阻塞的问题，将任务分为异步和同步
- 同步和异步任务分别进入不同的执行"场所"：**同步的进入主线程，异步的进入Event Table，即事件表格并注册函数**
- 当满足触发回调的条件时，Event Table会将这个函数移入**Event Queue，即任务队列**（任务队列还分为宏任务与微任务）
- 主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，先读取微任务队列，当微任务队列为空才可以读取宏任务队列，进而进入主线程执行
- 上述过程会不断重复，也就是常说的**Event Loop(事件循环)**。

**event loop的来源**

**Event Loop** 不是由 ECMAScript 标准（即 JavaScript 语言规范）定义的
而是由 **宿主环境**（如浏览器的 HTML Standard 或 Node.js 的 libuv）实现和管理的

### 什么是Event Table

- **定义**：Event Table 是一个**存储异步任务及其回调函数的映射表**，记录哪些事件（如定时器、网络请求、DOM事件等）完成后需要触发对应的回调。
- **位置**：它存在于`浏览器或Node.js的事件循环（Event Loop）机制`中，是`连接异步任务和回调队列的桥梁`

### monitoring process进程

> 怎样知道主线程执行栈为空呢？
> **js引擎存在monitoring process进程**

**作用**
* 这个进程会持续不断的检查主线程执行栈是否为空
* 一旦为空，就会去Event Queue那里检查是否有等待被调用的函数


### setTimeout、setInterval、requestAnimationFrame
#### setTimeout

> 在定时器的使用过程中，我们可能遇到这种问题：
> `setTimeout`有时候明明写的延时3秒，实际却5，6秒才执行函数，这是回事啊

- `setTimeout` 的回调属于 **宏任务**，必须等待：
    1. 当前所有同步代码执行完毕。
    2. **微任务队列**（如 `Promise`）清空。
    3. 可能存在的 UI 渲染（浏览器环境下）。
- 如果这些步骤耗时较长，`setTimeout` 的回调会被推迟。

* 浏览器/Node.js 对 `setTimeout` 有 **最小延迟阈值**（通常 4ms 或更高）
  `这也可以解释第二个参数为0时定时器也不会立马执行`


#### setInterval

> 与setTimeout类似

对于执行顺序来说，`setInterval`会每隔指定的时间将注册的函数置入Event Queue，如果前面的任务耗时太久，那么同样需要等待

对于`setInterval(fn,ms)`来说，我们已经知道不是每过`ms`秒会执行一次`fn`
而是每过`ms`秒，会有`fn`进入Event Queue

一旦 **`setInterval`的回调函数`fn`执行时间超过了延迟时间`ms`，那么就完全看不出来有时间间隔了**

#### requestAnimationFrame

**`requestAnimationFrame` 是浏览器专门为动画提供的API**

requestAnimationFrame刷新频率与显示器的刷新频率保持一致，使用该api可以避免使用setTimeout/setInterval造成动画卡顿的情况

requestAnimationFrame：告诉浏览器在下次重绘之前执行传入的回调函数(通常是操纵dom，更新动画的函数)

#### 三者的区别

**1. 引擎方面**
* setTimeout属于 `JS引擎` ，存在事件轮询  
* requestAnimationFrame 属于 `GUI引擎`  
* `JS引擎与GUI引擎`是互斥的，也就是说 GUI引擎在渲染时会阻塞JS引擎的计算

这样设计的原因，如果在GUI渲染的时候，JS同时又改变了dom，那么就会造成页面渲染不同步

**2. 性能方面**

* 当页面被隐藏或最小化时，定时器 setTimeout仍会在后台执行动画任务

* 当页面处于未激活的状态下，该页面的屏幕刷新任务会被系统暂停，requestAnimationFrame也会停止

### Promise与process.nextTick(callback)

* `process.nextTick(callback)`类似node.js版的"setTimeout"，在事件循环的下一次循环中调用 callback 回调函数；but它是微任务

### 执行顺序例题
```js
console.log('1'); // 1

setTimeout(function() {
    console.log('2'); // 2
    process.nextTick(function() {
        console.log('3'); // 微2.1
    })
    new Promise(function(resolve) {
        console.log('4'); // 4
        resolve();
    }).then(function() {
        console.log('5') // 微2.2
    })
}) // 宏1
process.nextTick(function() {
    console.log('6');
}) // 微1
new Promise(function(resolve) {
    console.log('7'); // 7
    resolve();
}).then(function() {
    console.log('8') // 微2
})

setTimeout(function() {
    console.log('9');
    process.nextTick(function() {
        console.log('10');
    })
    new Promise(function(resolve) {
        console.log('11');
        resolve();
    }).then(function() {
        console.log('12')
    })
}) // 宏2

```

输出：
```js
1 7 6 8 2 4 3 5 9 11 10 12
```

### 关于event loop的误区

- **“Event Loop 是 JavaScript 引擎的一部分”**：  
    错误！Event Loop 由 **宿主环境**（浏览器/Node.js）提供，JavaScript 引擎（如 V8）只负责执行同步代码。
    
- **“异步任务是在后台线程执行的”**：  
    部分正确。`setTimeout`/`fetch` 的监听由底层线程处理，但回调执行仍在主线程


### 浏览器与Node的事件循环(Event Loop)有何区别?

* 浏览器环境下，microtask 的任务队列是每个macrotask 执行完之后执行
* 而在 Node.js 中，microtask 会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行 microtask 队列的任务


### 浏览器更新渲染时期

- 在一轮event loop中多次修改同一dom，只有最后一次会进行绘制。
- 渲染更新（Update the rendering）会在event loop中的`宏任务和微任务`完成后进行
- 宏任务队列中，如果有大量任务等待执行时，将`dom的变动作为微任务，能更快的将变化呈现给用户`，这样就可以在这一次的事件循环中更新dom
- 但并不是每轮event loop都会更新渲染，这取决于是否修改了dom和浏览器觉得是否有必要在此时立即将新状态呈现给用户
- 如果在一帧的时间内（时间并不确定，因为浏览器每秒的帧数总在波动，16.7ms只是估算并不准确）修改了多处dom，浏览器可能将变动积攒起来，只进行一次绘制，这是合理的。
- 如果希望在每轮event loop都即时呈现变动，可以使用requestAnimationFrame。

### Vue的异步更新

> Vue 在更新 DOM 时是**异步执行**的
> 只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更
> 如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的

**vue nextTick为什么要优先使用微任务实现？**
1） vue nextTick的源码实现，优先级判断，总结就是`Promise > MutationObserver > setImmediate > setTimeout`

2）这里优先使用Promise，因为根据event loop与浏览器更新渲染时机，使用微任务，本次event loop轮询就可以获取到更新的dom

3）如果使用宏任务，要到下一次event loop中，才能获取到更新的dom

### Node中的process.nextTick

process.nextTick 是 Node.js 自身定义实现的一种机制，有自己的 `nextTickQueue`

**process.nextTick执行顺序早于微任务**




