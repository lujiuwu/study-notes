# 原始值和引用值
> 原始值就是最简单的数据 引用值则是由多个值构成的对象
> * 保存原始值的变量是按值访问的
> * 引用值是保存在内存中的对象 在操作对象时 实际上操作的是对该对象的引用而非对象本身 为此 保存引用值的变量是按引用访问的

## 动态属性
原始值和引用值的定义方法很类似，都是创建一个变量然后赋值
但是在变量存值之后可以对值进行什么操作则大有不同
对于引用值而言 可以随时添加 修改和删除其属性和方法 如：
```js
let person = {name:1,age:1}
person.name = 2
```
原始值不能有属性 尽管尝试给原始值添加属性不会报错
```js
let name = 1
name.age = 1
console.log(name.age) // undefined
```
**只有引用值可以动态添加后面可以使用的属性**
### 原始类型的初始化
> 原始类型的初始化可以只使用`原始字面量` 如果使用的new关键字 则JS会创建一个`Object`类型的实例 但其行为类似原始值

```js
let name1 = "cy"
let name2 = new String("cyy")
name1.age = 1
name2.age = 2
console.log(name1.age) // undefined
console.log(name2.age) // 2
console.log(typeof name1) // string
console.log(typeof name2) // object
```
## 复制值
> 除了存储方式不同 原始值和引用值在通过变量复制时也有所不同

### 复制原始值
在通过变量把一个原始值赋值到另一个变量时 原始值会被复制到新变量的位置。如
```js
let num1 = 1
let num2 = num1
```
num1和num2的存储是**完全独立的** 因为num2是num1的副本
两个变量可以独立使用 互不干扰

### 复制引用值
把引用值从一个变量复制给另一个变量时 存储在变量中的值也会被复制到新变量所在的位置 区别在于：
* 这里的复制实际上是一个指针 它指向存储在堆内存中的对象
* 操作完成后 两个变量实际指向同一个对象
因此 **一个变量上的变化会在另一个对象上反映出来**
```js
let obj1 = new Object();

let obj2 = obj1;

obj1.name = "Nicholas";

console.log(obj2.name); // "Nicholas"
```

## 传递参数
> ES中的所有函数的`参数都是按值传递`的 这意味着函数外的值会被复制到函数内部的参数中 就像一个变量复制到另一个变量一样 

* 如果是原始值 就跟原始值变量的复制一样
* 如果是引用值 就和引用值变量的复制一样

## 确定类型
typeof操作符最适合判断一个变量是否为原始类型
```js
let s = "Nicholas";

let b = true;

let i = 22;

let u;

let n = null;

let o = new Object();

console.log(typeof s); // string

console.log(typeof i); // number

console.log(typeof b); // boolean

console.log(typeof u); // undefined

console.log(typeof n); // object

console.log(typeof o); // object
```

typeof虽然对原始值很有用 但是对引用值的用处不大 我们通常不关心一个值是不是对象 而是想知道它是什么类型的对象 为了解决这个问题 ES提供了`instanceof操作符`
```js
let num = 1;
let res = num instanceof Number
console.log(res) // true
let Person = {name:'cy',age:11}
let res2 = Person instanceof Object
console.log(res2) // true
let arr = [1,2,3]
console.log(arr instanceof Array) // true
```

typeof对正则表达式也返回function 在IE和Firefox中返回objcect

# 执行上下文与作用域
变量或函数的上下文决定了它们可以访问哪些数据以及它们的行为
每个上下文都有关联的**变量对象** 而这个上下文中定义的所有变量和函数都存在于这个对象上 
## 全局上下文
全局上下文是最外层的上下文 在浏览器中 全局上下文就是我们常说的window对象 因此所有通过var定义的全局变量和函数都会成为window对象的属性和方法

通过let和const的顶级声明不会定义在全局上下文中(块作用域)

每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。在函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。

ECMAScript程序的执行流就是通过这个上下文栈进行控制的。

上下文中的代码在执行的时候，会创建变量对象的一个`作用域链（scope chain）`。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。
代码正在执行的上下文的变量对象始终位于作用域链的最前端。如果上下文是函数，则其活动对象（activation object）用作变量对象。活动对象最初只有一个定义变量：arguments。（全局上下文中没有这个变量。）作用域链中的下一个变量对象来自包含上下文，再下一个对象来自再下一个包含上下文。以此类推直至全局上下文；全局上下文的变量对象始终是作用域链的最后一个变量对象。
代码执行时的标识符解析是通过沿作用域链逐级搜索标识符名称完成的。搜索过程始终从作用域链的最前端开始，然后逐级往后，直到找到标识符。（如果没有找到标识符，那么通常会报错。）

## 作用域链增强
虽然执行上下文主要有全局上下文和函数上下文两种 但是有其他方式来增强作用域链 某些语句会导致在作用域链前端临时添加一个上下文 这个上下文在代码执行后会被删除 通常在两种情况下会出现这个情况 即代码执行到下面任意一种情况时：
* try/catch 语句的 catch块
* with语句

## 变量声明
### 使用var的函数作用域声明
在使用var声明变量时 变量会自动添加到最近的上下文中 在函数中 最接近的上下文就是函数的局部上下文 在with语句中 最接近的上下文也是函数上下文 如果变量未经声明就被初始化了 那么它就会自动被添加到全局上下文
```js
function add(num1, num2) {

var sum = num1 + num2;

return sum;

}

let result = add(10, 20); // 30

console.log(sum); // 报错：sum 在这里不是有效变量


// 此处sum未经声明就初始化了 自动被添加到全局上下文 故在函数外也能被访问
function add(num1, num2) {

sum = num1 + num2;

return sum;

}

let result = add(10, 20); // 30

console.log(sum); // 30

```

var声明会被拿到函数或者全局作用域的顶部 位于作用域中所有代码之前 这个现象叫做`“提升”`
提升让同一作用域中的代码不必考虑变量是否已经声明就可以直接使用

### 使用let的块级作用域声明
let和var相似 但let的作用域是块级的 
**块级作用域由最近的一对包含花括号{ }界定**
let和var的另一个不同之处及时 ：在同一作用域内不能声明两次 重复的var声明会被忽略 而重复的let航母会抛出SyntaxError

### 使用const的常量声明
使用 const 声明的变量必须同时初始化为某个值。一经声明，在其生命周期的任何时候都不能再重新赋予新值。
const 声明只应用到顶级原语或者对象。换句话说，赋值为对象的 const 变量不能再被重新赋值为其他引用值，但`对象的键则不受限制`。
如果想让整个对象都不能修改，可以使用 `Object.freeze()`，这样再给属性赋值时虽然不会报错，但会静默失败：
```js
const o3 = Object.freeze({});

o3.name = 'Jake';

console.log(o3.name); // undefined
```

### 标识符查找
当在特定上下文中为读取或写入而引用一个标识符时，必须通过搜索确定这个标识符表示什么。
搜索开始于作用域链前端，以给定的名称搜索对应的标识符。如果在局部上下文中找到该标识符，则搜索停止，变量确定；如果没有找到变量名，则继续沿作用域链搜索。
（注意，作用域链中的对象也有一个原型链，因此搜索可能涉及每个对象的原型链。）这个过程一直持续到搜索至全局上下文的变量对象。如果仍然没有找到标识符，则说明其未声明。
如果局部上下文中有一个同名的标识符，那就不能在该上下文中引用父上下文中的同名标识符
```js
let color = "blue"
function getColor(){
  let color = "green"
  return color 
}
console.log(getColor()) // green but not blue
```
在局部变量 color 声明之后的任何代码都无法访问全局变量color，除非使用完全限定的写法window.color。
**注意**
标识符查找并非没有代价。访问局部变量比访问全局变量要快，因为不用切换作用域。

# 垃圾回收（没搞清楚）
> JS是使用垃圾回收的语言 也就是执行环境负责在代码执行时管理内存
> 基本思路：确定哪个变量不会再使用 然后释放它占用的内存；这个过程是周期性的，程序每隔一段时间自动运行；然后，某块内存是否有用是不可判定的，该过程是一个近似但不完美的方案

垃圾回收程序必须跟踪记录哪个变量还会使用，以及哪个变量不会再使用，以便回收内存。如何标记未使用的变量也许有不同的实现方式。不过，在浏览器的发展史上，用到过两种主要的标记策略：
**标记清理和引用计数。**

## 标记清除（最常用）
当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记。而在上下文中的变量，逻辑上讲，永远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们。当变量离开上下文时，也会被加上离开上下文的标记。

给变量加标记的方式有很多种。比如，当变量进入上下文时，反转某一位；或者可以维护“在上下文中”和“不在上下文中”两个变量列表，可以把变量从一个列表转移到另一个列表。标记过程的实现并不重要，关键是策略。

垃圾回收程序运行的时候，会标记内存中存储的所有变量（记住，标记方法有很多种）。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存。

## 引用计数
其思路是对每个值都记录它被引用的次数。声明变量并给它赋一个引用值时，这个值的引用数为 1。如果同一个值又被赋给另一个变量，那么引用数加 1。类似地，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减 1。当一个值的引用数为 0 时，就说明没办法再访问到这个值了，因此可以安全地收回其内存了。垃圾回收程序下次运行的时候就会释放引用数为 0 的值的内存。
**问题 -- 循环引用**：
所谓循环引用，就是对象 A 有一个指针指向对象 B，而对象 B 也引用了对象 A。在这种情况下，它们的引用数永远不可能为0 如果函数被多次调用就会造成大量内存无法释放
 
为此，Netscape 在 4.0 版放弃了引用计数，转而采用标记清理。事实上，引用计数策略的问题还不止于此。

## 性能
垃圾回收程序会周期性运行，如果内存中分配了很多变量，则可能造成性能损失，因此垃圾回收的==时间调度==很重要。尤其是在内存有限的移动设备上，垃圾回收有可能会明显拖慢渲染的速度和帧速率。开发者不知道什么时候运行时会收集垃圾，因此最好的办法是在写代码时就要做到：
**无论什么时候开始收集垃圾，都能让它尽快结束工作。**

IE7 发布后，JavaScript 引擎的垃圾回收程序被调优为==动态改变分配变量、字面量或数组槽位等会触发垃圾回收的阈值。==
## 内存管理

在使用垃圾回收的编程环境中，开发者通常无须关心内存管理。
不过，JavaScript 运行在一个内存管理与垃圾回收都很特殊的环境。分配给浏览器的内存通常比分配给桌面软件的要少很多，分配给移动浏览器的就更少了。
这更多出于安全考虑而不是别的，就是为了避免运行大量 JavaScript 的网页耗尽系统内存而导致操作系统崩溃。这个内存限制不仅影响变量分配，也影响调用栈以及能够同时在一个线程中执行的语句数量。

因此，**将内存占用量保持在一个较小的值可以让页面性能更好**。优化内存占用的最佳手段就是保证在执行代码时只保存必要的数据。如果数据不再必要，那么把它设置为 null，从而释放其引用。这也可以叫作解除引用。这个建议最适合全局变量和全局对象的属性。局部变量在超出作用域后会被自动解除引用

不过要注意，解除对一个值的引用并不会自动导致相关内存被回收。解除引用的关键在于确保相关的值已经不在上下文里了，因此它在下次垃圾回收时会被回收。

* **const和let声明：** const和let都以块为作用域 相较于var可能会更早让垃圾回收程序介入，在块作用域比函数作用域更早终止的情况下就有可能发生
* **隐藏类和删除操作：** V8 js引擎
* **内存泄漏：** 意外声明全局变量是最常见但也最容易修复的内存泄漏问题。
* **静态分配与对象池：** 


