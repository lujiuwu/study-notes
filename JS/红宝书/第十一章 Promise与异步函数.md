# 异步编程
异步行为是为了优化因计算量大而时间长的操作。如果在等待其他操作完成的同时，即使运行其他指令，系统也能保持稳定，那么这样做就是务实的
重要的是，异步操作并不一定计算量大或要等很长时间。只要你不想为等待某个异步操作而阻塞线程执行，那么任何时候都可以使用。
## 异步与同步
### 同步
同步行为对应内存中`顺序执行`的处理器指令。每条指令都会`严格按照它们出现的顺序来执行`，而每条指令执行后也能`立即获得存储在系统本地（如寄存器或系统内存）的信息`。这样的执行流程容易分析程序在执行到代码任意位置时的状态（比如变量的值）
### 异步
异步行为类似于`系统中断`，即当前进程外部的实体可以触发代码执行。异步操作经常是必要的，因为强制进程等待一个长时间的操作通常是不可行的（同步操作则必须要等）。如果代码要访问一些高延迟的资源，比如向远程服务器发送请求并等待响应，那么就会出现长时间的等待

### 以往的异步编程模式
在早期的 JavaScript 中，只支持定义回调函数来表明异步操作完成。串联多个异步操作是一个常见的问题，通常需要深度嵌套的回调函数（俗称“回调地狱”）来解决

# Promise
## Promise A+规范
为弥合现有实现之间的差异，2012 年 Promises/A+组织分叉（fork）了 CommonJS 的 Promises/A 建议，并以相同的名字制定了 Promises/A+规范。这个规范最终成为了ECMAScript 6 规范实现的范本
## Promise基础
### 实例化
* 通过new关键字实例化
* 创建新期约时需要传入`执行器（executor）函数`作为参数
```js
const promise = new Promise(()=>{})
```
### Promise状态机
> Promise是一个有状态的对象，可以处于以下三种状态：
> * pending
> * fulfilled
> * rejected

* pending是Promise的最初状态
* Promise的状态是**私有的**，不能直接通过JS检测到，这主要是为了避免根据读取到的状态以同步方式处理该Promise对象
* pending->fulfilled和pending->rejected的状态转换是不可逆的
### 解决值，拒绝理由及Promise用例
Promoise主要有两大用途，首先是抽象地表示一个异步操作。期约的状态代表期约是否完成。“待定”表示尚未开始或者正在执行中。“兑现”表示已经成功完成，而“拒绝”则表示没有成功完成
每个期约只要状态切换为兑现，就会有一个私有的内部值（value）。类似地，每个期约只要状态切换为拒绝，就会有一个私有的内部理由（reason）。无论是值还是理由，都是包含原始值或对象的不可修改的引用。二者都是可选的，而且默认值为 undefined。在期约到达某个落定状态时执行的异步代码始终会收到这个值或理由。
### 通过执行函数控制Promise状态

# 异步函数
> 异步函数，也称为“async/await”（语法关键字），是 ES6 期约模式在 ECMAScript 函数中的应用
> async/await 是 ES8 规范新增的

## async
async函数用于声明异步函数，这个关键字可以用在`函数声明，函数表达式，箭头函数和方法上`

