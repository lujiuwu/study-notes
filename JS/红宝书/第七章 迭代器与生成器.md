> “迭代”的意思是按照顺序反复多次执行一段程序，通常会有明确的终止条件。ECMAScript 6 规范新增了两个高级特性：**迭代器和生成器**。使用这两个特性，能够更清晰、高效、方便地实现迭代。

# 理解迭代
## 计数循环
> 计数循环是一种最简单的迭代：for(let i = 0 ;i<3;i++)...
> 
> 迭代会在一个有序集合上进行。（“有序”可以理解为集合中所有项都可以按照既定的顺序被遍历到，特别是开始和结束项有明确的定义。）

**数组中计数循环的缺点**
* 迭代前需要事先知道如何使用数据结构 使用[ ]操作符来获取特定索引上的值并不适用于所有数据结构
* 遍历顺序不是所有数据结构固有的 通过递增索引来访问数据是特定于数组类型的方式，并不适用于其他具有隐式顺序的数据结构

## Array.prototype.forEach
```js
let collection = ['foo', 'bar', 'baz'];

collection.forEach((item) => console.log(item));
```
**缺点：**
没有办法标识迭代何时终止。因此这个方法只适用于数组，而且回调结构也比较笨拙。

# 迭代器模式
> 迭代器模式（特别是在 ECMAScript 这个语境下）描述了一个方案，即可以把有些结构称为“可迭代对象”（iterable），因为它们实现了正式的 Iterable 接口，而且可以通过迭代器 Iterator 消费。

任何实现 Iterable 接口的数据结构都可以被实现 Iterator 接口的结构“消费”（consume）。
迭代器（iterator）是`按需创建的一次性对象`。每个迭代器都会关联一个可迭代对象，而迭代器会暴露迭代其关联可迭代对象的 API。
迭代器`无须了解与其关联的可迭代对象的结构`，只需要知道如何取得连续的值。这种概念上的`分离`正是 Iterable 和 Iterator 的强大之处。

## 可迭代协议
> 实现 Iterable 接口（可迭代协议）要求同时具备两种能力：支持迭代的自我识别能力和创建实现Iterator 接口的对象的能力
> 
> 这意味着必须暴露一个属性作为“默认迭代器”，而且这个属性必须使用特殊的 `Symbol.iterator` 作为键
> 
> 这个默认迭代器属性必须引用一个`迭代器工厂函数`，调用这个工厂函数必须返回一个新迭代器
> 
> 很多内置类型都实现了 Iterable 接口：字符串，数组，映射，集合，arguements对象，DOM集合类型

**检查是否存在默认迭代器属性 -- 暴露这个Symbol.iterator工厂类型**
```js
let arr = new Array([1,2,3])
let num = 1
console.log(arr[Symbol.iterator]) 
console.log(num[Symbol.iterator])
```

实际写代码过程中，不需要显式调用这个工厂函数来生成迭代器。实现可迭代协议的所有类型都会自动兼容接收可迭代对象的任何语言特性。
接收可迭代对象的原生语言特性包括：
 for-of 循环
 数组解构
 扩展操作符
 Array.from()
 创建集合
 创建映射
 Promise.all()接收由期约组成的可迭代对象
 Promise.race()接收由期约组成的可迭代对象
 yield*操作符，在生成器中使用

## 迭代器协议
> 迭代器是一种一次性使用的对象，用于迭代与其关联的可迭代对象。

迭代器 API 使用 next()方法在可迭代对象中遍历数据。每次成功调用 next()，都会返回一个 IteratorResult 对象，其中包含迭代器返回的下一个值。若不调用 next()，则无法知道迭代器的当前位置。

### next( )方法
> next()方法返回的迭代器对象 IteratorResult 包含两个属性：`done 和 value`

#### 属性
* done 是一个布尔值，表示是否还可以再次调用 next()取得下一个值
* value 包含可迭代对象的下一个值（done 为false），或者 undefined（done 为 true）。done: true 状态称为“耗尽”。

![](JS/红宝书/noteImg/Pasted%20image%2020250306153326.png)

迭代器并不知道怎么从可迭代对象中取得下一个值，也不知道可迭代对象有多大。只要迭代器到达 done: true 状态，后续调用 next()就一直返回同样的值了：
{value:undefined,done:true}
#### 独立性
> 每个迭代器都表示对可迭代对象的一次性有序遍历。不同迭代器的实例相互之间没有联系，只会独立地遍历可迭代对象：
![](JS/红宝书/noteImg/Pasted%20image%2020250306154434.png)
#### 游标记录
> 迭代器并不与可迭代对象某个时刻的快照绑定，而仅仅是使用游标来记录遍历可迭代对象的历程。如果可迭代对象在迭代期间被修改了，那么迭代器也会反映相应的变化：
![](JS/红宝书/noteImg/Pasted%20image%2020250306154639.png)
#### 垃圾回收
**迭代器维护着一个指向可迭代对象的引用，因此迭代器会阻止垃圾回收程序回收可迭代对象**

## 自定义迭代器
为了让一个可迭代对象能够创建多个迭代器，必须每创建一个迭代器就对应一个新计数器。为此，可以把计数器变量放到闭包里，然后通过闭包返回迭代器：
```js
class Counter{
  constructor(limit){
    this.limit = limit
  }
  [Symbol.iterator](){
    let count = 1
    let limit = this.limit
    return {
      next(){
        if(count<=limit) return {done:false,value:count++}
        else return {done:true,value:undefined}
      }
    }
  }
}
```

## 提前终止迭代器
> 可选的 return()方法用于指定在迭代器提前关闭时执行的逻辑。执行迭代的结构在想让迭代器知道它不想遍历到可迭代对象耗尽时，就可以“关闭”迭代器。可能的情况包括：
> 
> * for-of循环提前退出
> * 解构操作并未消费所有值
### 返回值
return()方法必须返回一个有效的 IteratorResult 对象。简单情况下，可以只返回{ done: true }。因为这个返回值只会用在生成器的上下文中

```js
class Counter{
  constructor(limit){
    this.limit = limit
  }
  [Symbol.iterator](){
    let count = 1
    let limit = this.limit
    return {
      next(){
        if(count<=limit) return {done:false,value:count++}
        else return {done:true,value:undefined}
      },
      // 提前终止
      return(){
        console.log("end")
        return {done:true}
      }
    }
  }
}
```
### 无返回值
> 如果迭代器没有关闭，则还可以继续从上次离开的地方继续迭代。比如，数组的迭代器就是不能关闭的

```js
let a = [1, 2, 3, 4, 5];

let iter = a[Symbol.iterator]();

for (let i of iter) {

console.log(i);

if (i > 2) {

break

}

}

// 1

// 2

// 3

for (let i of iter) {

console.log(i);

}

// 4

// 5
```

### return不会强制关闭
因为 return()方法是可选的，所以并非所有迭代器都是可关闭的。要知道某个迭代器是否可关闭，可以测试这个迭代器实例的 return 属性是不是函数对象。
不过，仅仅给一个不可关闭的迭代器增加这个方法并不能让它变成可关闭的。这是因为调用 return()不会强制迭代器进入关闭状态。即便如此，return()方法还是会被调用。

# 生成器
> 生成器是 ECMAScript 6 新增的一个极为灵活的结构，拥有在一个函数块内`暂停和恢复代码执行的能力`。这种新能力具有深远的影响，比如，使用生成器可以自定义迭代器和实现协程。

## 生成器基础
### 生成器函数
生成器的形式是一个函数，函数名称前面加一个星号（ * ）表示它是一个生成器。只要是可以定义函数的地方，就可以定义生成器。
```js
// 生成器函数声明

function* generatorFn() {}

// 生成器函数表达式

let generatorFn = function* () {}

// 作为对象字面量方法的生成器函数

let foo = {

* generatorFn() {}

}

// 作为类实例方法的生成器函数

class Foo {

* generatorFn() {}

}

// 作为类静态方法的生成器函数

class Bar {

static * generatorFn() {}

}
```

**注意：** 
* 箭头函数不能用来定义生成器函数
* 标识生成器函数的星号不受两侧空格的影响

### 生成器对象
> 调用生成器函数会产生一个生成器对象。生成器对象一开始处于暂停执行（suspended）的状态。
> 与迭代器相似，生成器对象也实现了 Iterator 接口，因此具有 next()方法。调用这个方法会让生成器开始或恢复执行。

```js
function* generatorFn() {}

const g = generatorFn();

console.log(g); // generatorFn {<suspended>}

console.log(g.next); // f next() { [native code] }
```

next()方法的返回值类似于迭代器，有一个 done 属性和一个 value 属性。函数体为空的生成器函数中间不会停留，调用一次 next()就会让生成器到达 done: true 状态。

```js
function* generatorFn() {}

let generatorObject = generatorFn();

console.log(generatorObject); // generatorFn {<suspended>}

console.log(generatorObject.next()); 
// { done: true, value: undefined }
```

#### value -- 生成器函数的返回值
> value 属性是生成器函数的返回值，默认值为 undefined，可以通过生成器函数的返回值指定：

```js
function *generatorFunction(){return 'cy'}
const g = generatorFunction()
console.log(generatorObject); // generatorFn {<suspended>}
console.log(generatorObject.next()); // { done: true, value: 'cy' }
```
#### 生成器函数的执行时机
> 生成器函数只会在`初次调用next()方法`后执行

```js
function* generatorFn() {

console.log('foobar');

}

// 初次调用生成器函数并不会打印日志

let generatorObject = generatorFn();

generatorObject.next(); // foobar
```

### yield -- 生成器中断执行
> yield 关键字可以让生成器停止和开始执行，也是生成器最有用的地方。生成器函数在遇到 yield关键字之前会正常执行。
> 遇到这个关键字后，执行会停止，函数作用域的状态会被保留。停止执行的生成器函数只能通过在生成器对象上调用 next()方法来恢复执行：
#### 单独使用
```js
function* generatorFn() {

  yield;

}

let generatorObject = generatorFn();

console.log(generatorObject.next()); // { done: false, value: undefined }

console.log(generatorObject.next()); // { done: true, value: undefined }
```
#### 生成值
> yield关键字生成的值val会出现在next( )方法返回的对象里:
> {done:false,value:val}
> * 通过yield关键字退出的生成器函数会处于`done:false`状态

```js
function *generatorFunction(){
  yield "end tag"
  yield "end tag2"
}
const fun = generatorFunction
console.log(fun.next()) // {done:false,value:"end tag"}
console.log(fun.next()) // {done:false,value:"end tag2"}
```

#### 独立性
> 生成器函数内部的执行流程会针对每个生成器对象区分作用域。在一个生成器对象上调用 next()不会影响其他生成器(每个生成器独立存在互不干涉)：

```js
function* generatorFn() {

yield 'foo';

yield 'bar';

return 'baz';

}

let generatorObject1 = generatorFn();

let generatorObject2 = generatorFn();

console.log(generatorObject1.next()); // { done: false, value: 'foo' }

console.log(generatorObject2.next()); // { done: false, value: 'foo' }
```

#### 使用位置
> yield 关键字只能在生成器函数内部使用，用在其他地方会抛出错误
> 类似函数的 return 关键字，yield 关键字必须直接位于生成器函数定义中，出现在嵌套的非生成器函数中会抛出语法错误：

```js
// 有效
function* validGeneratorFn() {

yield;

}

// 无效
function* invalidGeneratorFnA() {

function a() {

yield;

}

}

// 无效
function* invalidGeneratorFnB() {

const b = () => {

yield;

}

}

// 无效
function* invalidGeneratorFnC() {

(() => {

yield;

})();

}
```

#### 应用场景

##### 1. 生成器对象作为可迭代对象(自定义迭代对象)
**原理**：yield中断生成器返回的结果是可迭代对象
**代码**：
```js
function *generatorFunction(n){
  while(n--){yield n}
}
for (const x of generatorFunction(3)) {
  console.log(x);
}
```

##### 2. 使用yield实现输入和输出
**原理**：yield 关键字可以作为函数的中间参数使用，因为上一次让生成器函数暂停的 yield 关键字会接收到传给 next()方法的第一个值
**注意**：第一次调用 next()传入的值不会被使用，因为这一次调用是为了开始执行生成器函数

##### 3. 产生可迭代对象
**原理**：可以使用星号增强 yield 的行为，让它能够迭代一个可迭代对象，从而一次产出一个值：

```js
function* generatorFn() {
  yield* [1, 2, 3];
}

let generatorObject = generatorFn();
for (const x of generatorFn()) {
  console.log(x);
}

// 1
// 2
// 3
```

因为 yield* 实际上只是将一个可迭代对象序列化为一连串可以单独产出的值，所以这跟把 yield放到一个循环里没什么不同。

##### 4. 使用yield * 实现递归算法
```js
function* nTimes(n) {

if (n > 0) {

yield* nTimes(n - 1);

yield n - 1;

}

}

for (const x of nTimes(3)) {

console.log(x);

}

// 0

// 1

// 2
```
### 生成器作为默认迭代器
```js
class foo{
  contructor(){
    this.values = [1,2,3]
  }
  * [Symbol.iterator](){
    yield* this.values
  }
}
```

### 提前终止生成器
#### 1. return( )
> return()方法会强制生成器进入关闭状态。提供给 return()方法的值，就是终止迭代器对象的值：

```js
function* generatorFn() {

for (const x of [1, 2, 3]) {

yield x;

}

}

const g = generatorFn();

console.log(g); // generatorFn {<suspended>}

console.log(g.return(4)); // { done: true, value: 4 }

console.log(g); // generatorFn {<closed>}
```

**注意：**
与迭代器不同的是，只要生成器对象通过return( )方法进入关闭状态，则不可恢复：1. 后续调用next( )方法只会返回`{done:true}`；2. 提供给生成器函数的任何返回值都不会被存储和传播

#### 2. throw( )
> throw()方法会在暂停的时候将一个提供的错误注入到生成器对象中。如果错误未被处理，生成器就会关闭：

* **基础使用 -- 不处理错误**
```js
function* generatorFn() {

  for (const x of [1, 2, 3]) {

    yield x;

  }

}

const g = generatorFn();

console.log(g); // generatorFn {<suspended>}

try {

  g.throw('foo');

} catch (e) {

  console.log(e); // foo

}

console.log(g); // generatorFn {<closed>}
```

* **处理错误 -- 生成器不会关闭且可以恢复执行** 
```js
function* generatorFn() {
  for (const x of [1, 2, 3]) {
    try {
      yield x;
    } catch(e) {}
  }
}

const g = generatorFn();
console.log(g.next()); // { done: false, value: 1}
g.throw('foo');
console.log(g.next()); // { done: false, value: 3}
```

