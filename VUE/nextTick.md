### 什么是nextTick

#### 浏览器

浏览器（多进程）包含了**Browser进程**（浏览器的主进程）、**第三方插件进程**、**GPU进程**和**渲染进程**等，其中**渲染进程**（多线程）和Web前端密切相关，包含以下线程：

- **渲染进程（Renderer Process）**
  - **主线程（Main Thread，唯一）**
    ├─ 核心功能：
    │   ├─ **JS执行**（V8引擎）
    │   ├─ **事件循环**（任务调度中枢）
    │   └─ **渲染流水线**（三阶段）：
    │       ├─ DOM/CSS解析 → 构建渲染树（GUI线程）
    │       ├─ 布局（Layout）→ 计算几何信息
    │       └─ 绘制（Paint）→ 生成绘制指令
    │
    └─  Web平台API实现（如setTimeout/fetch）

> **GUI渲染线程**和**JS引擎线程**是互斥的，为了防止DOM渲染的不一致性，其中一个线程执行时另一个线程会被挂起。

这些线程中，和Vue的`nextTick`息息相关的是**JS引擎线程**和**事件触发线程**

**总结**
* 渲染进程是只有一个主线程的进程，所有核心工作在这里完成
  `这也回答了“为什么JS是单线程”的问题`
* 主线程有三大核心机制：
     1. JS引擎（`执行JS`)
     2. 事件触发线程：事件循环（`工作调度系统`）
     3. 渲染流水线（`俗称GUI渲染`）
* 需要注意：1. JS引擎与GUI渲染是互斥关系

**关于事件触发线程（有争议）**
- 浏览器**没有**名为"事件触发线程"的独立线程
- 事件处理是由**主线程**通过事件循环完成的

#### JS引擎线程与事件触发线程

> 浏览器页面初次渲染完毕后，**JS引擎线程**结合**事件触发线程**的工作流程如下

* 同步任务在**JS引擎线程**（主线程）上执行，形成**执行栈**（Execution Context Stack）
* 主线程之外，**事件触发线程**管理着一个**任务队列**（Task Queue）。只要异步任务有了运行结果，就在**任务队列**之中放置一个事件
* **执行栈**中的同步任务执行完毕，系统就会读取**任务队列**，如果有异步任务需要执行，将其加到主线程的**执行栈**并执行相应的异步任务

#### 事件循环机制

**JS**
* **事件触发线程**管理的**任务队列**是如何产生的呢？事实上这些任务就是从**JS引擎线程**本身产生的
* 主线程在运行时会产生**执行栈**，栈中的代码调用某些异步API时会在**任务队列**中添加事件
* 栈中的代码执行完毕后，就会读取**任务队列**中的事件，去执行事件对应的回调函数
* 如此循环往复，形成事件循环机制

**结合浏览器**
- 执行一个**宏任务**（首次执行的主代码块或者**任务队列**中的回调函数）
- 执行过程中如果遇到**微任务**，就将它添加到**微任务**的任务队列中
- **宏任务**执行完毕后，立即执行当前**微任务**队列中的所有任务（依次执行）
- **JS引擎线程**挂起，**GUI线程**执行渲染
- **GUI线程**渲染完毕后挂起，**JS引擎线程**执行**任务队列**中的下一个**宏任务**

#### 任务类型

**宏任务与微任务**
* script （主代码块）、`setTimeout` 、`setInterval` 、`setImmediate` 、I/O 、UI rendering
* `process.nextTick`（Nodejs） 、`promise` 、`Object.observe` 、`MutationObserver`

**怎样区分**
- 微任务适合处理高优先级任务（如DOM更新后的回调）
- 宏任务适合处理耗时操作（如网络请求、定时任务）

#### nodejs的process.nextTick

> `process.nextTick` 是 Node.js 特有的异步 API，用于将回调函数**延迟到当前执行栈的末尾、下一次事件循环开始前**执行
> 
> 它的优先级**比微任务（如 `Promise.then`）更高**，是 Node.js 中**最快的异步方法**

**执行时机**
* 在当前同步代码执行完后**立即执行**（早于微任务和宏任务）

**原理/特点**
* 不进入事件循环，直接插入当前执行栈末尾

**存在递归风险**
* 若递归调用 `process.nextTick`，会阻塞事件循环（类似同步死循环）

#### vue的nextTick API

> **官方描述：** 在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM

**产生背景**
* VUE的更新是异步的
* 无法做到立即获取新数据

**应用场景**
* 在修改数据后立即获得更新后的DOM状态
* 在组件渲染完成后执行某些操作
* 在子组件更新后，父组件根据子组件的状态执行某些操作


