# 计算机基础
## 设计模式

## 操作系统

**操作系统的作用**
* 硬件的协调工作，比如你的代码要协调CPU资源什么时候读取你的代码，什么时候把进程切换到别的进程。。。这些脏活累活都是操作系统帮你屏蔽了

### 操作系统的特征

* 并发
* 共享
* 虚拟
* 异步

#### 并发

**并行** -- 多个任务同时执行
**并发** -- 把时间分成若干段，`使多个任务交替的执行`

**操作系统的并发性**
指计算机系统中 `同时存在多个运行着的程序`

`CPU时间`片（操作系统分配给每个正在运行的进程微观上的一段CPU时间）轮着给进程执行的时间
因为执行速度很快，`看起来就像`浏览器能同时执行任务一样。

#### 共享

**什么是共享**
* 共享性是指多个进程可以同时访问同一资源

**共享与并发的关系**

* 如果没有并发，也就是只有一个进程在运行，那就没有共享了
* 如果没有共享，多个进程就不能同时发文件，无法同时访问硬盘资源，也就无法并发

**共享的两种方式**
* 互斥共享方法
  1. 系统中的某些资源，在一个时间段只能允许一个进程访问
  2. 这种资源叫做`独占资源`或者`临界资源`

* 同时共享方法
  1. 允许一个时间段由多个进程同时对资源进行访问

#### 虚拟

**什么是虚拟**
指通过抽象和资源复用的方式，让用户和应用程序**感知到的资源**与实际物理资源**存在差异**，从而创造更高效、更安全的计算环境

**虚拟技术**
* 空分复用技术 （如虚拟存储器技术）
* 时分复用技术（如虚拟处理器）
#### 异步

**什么是异步**
**异步性**指操作系统允许任务在**非阻塞**模式下执行，任务的发起与结果的返回在时间上解耦

比如，CPU正在执行一个进程，进程需要读取文件，读取文件可能要`1个小时`，那CPU不可能一直等一个小时，CPU会继续把`时间片`分给别的进程，等文件读取完成了（类似ajax返回结果了），`CPU再继续执行`之前被`中断`的进程

### 指令

**什么是指令**：CPU能识别和执行的最基本命令

#### 指令类型
**指令类型**
* 特权指令
* 非特权指令

#### CPU工作模式

**问题来了，CPU如何判断当前是否可以执行特权指令**

CPU通常有两种工作模式即：`内核态`和`用户态`，而在PSW（寄存器的标志位0表示用户态，1表示核心态）中有一个二进制位控制这两种模式。

对于应用程序而言，有的程序能执行特权指令，有的程序只能执行非特权指令。所以操作系统里的程序又分为两种：
* 内核程序 --- 操作系统的内核程序是系统的管理者，可以执行两种指令，运行在`内核态`
* 应用程序 --- 只能执行非特权指令，运行在`用户态`

### 操作系统内核

**操作系统内核包括**
* 进程管理，存储器管理，设备管理等功能
* 时钟管理，中断处理，原语，CPU切换等
  `跟硬件紧密相关的部分`

- 时钟管理。操作系统的时钟管理是依靠`硬件定时器`的。时钟管理相当重要，比如我们`获取时间信息`，`进程切换`等等都是要依靠时钟管理。
- 中断处理（下一小节会详细介绍）。
- 原语。可以简单理解为用来实现某个特定功能，在执行过程中`不可被中断`的指令集合。原语有一个非常重要的特性，就是**原子性**（其运行`一气呵成，不可中断`）

### 中断

**概念**
在程序运行过程中，系统出现了一个必须由CPU立即处理的情况
此时，CPU`暂时中止程序的执行`转而`处理这个新的情况`的过程就叫做`中断`

中断（Interrupt）是操作系统实现异步事件处理的核心机制
它允许**外部设备或内部异常**打断 CPU 的正常执行流程，转而执行特定的处理程序，并在完成后恢复原任务
中断机制是操作系统实现**并发、设备管理、错误处理**等功能的基础

- "用户态 ---> 核心态"  是通过中断实现的。`并且中断是唯一途径`。
- "核心态 ---> 用户态"  的切换时通过执行一个特权指令，将程序状态的标志位设为用户态

#### 中断的分类
##### 内中断
**内中断（内部异常/陷阱）** -- 由CPU内部事件触发的中断
* 由 CPU **主动检测** 并触发
- 与程序执行流强相关（如指令错误、系统调用）
- **不可屏蔽**（必须立即处理）
##### 外中断
**外中断（硬件中断）** -- 由 外部设备 触发，用于通知 CPU 异步事件（如 I/O 完成）
* 由 **设备控制器** 通过中断请求线（IRQ）触发
- 与当前执行的指令无关（异步事件）
- **可屏蔽**（可通过 CLI 指令关闭中断响应）

##### 面试考点
1. **内中断和外中断的本质区别是什么？**
    - 答：内中断由 CPU 内部事件触发（同步），外中断由外部设备触发（异步）。
        
2. **为什么缺页异常是内中断，而磁盘中断是外中断？**
    - 答：缺页异常是 CPU 执行指令时发现的错误（同步），磁盘中断是设备异步通知。
        
3. **中断屏蔽（CLI）能阻止内中断吗？为什么？**
    - 答：不能，内中断（如异常）不可屏蔽，必须立即处理。
        
4. **举例说明哪些场景会触发内中断和外中断？**
    - 内中断：系统调用、除零错误
    - 外中断：键盘输入、网络数据到达


### 系统调用

**概念**
系统调用（System Call）是**用户程序与操作系统内核交互的桥梁**，允许应用程序请求内核提供的服务（如文件操作、进程管理、网络通信等）。它是操作系统实现**资源隔离**和**权限控制**的核心机制

#### 系统调用的作用

1. **权限隔离**
    - 用户程序运行在**用户态**（受限模式），无法直接访问硬件或内核数据。
    - 通过系统调用进入**内核态**（特权模式），由内核代为执行敏感操作。
        
2. **资源抽象**
    - 提供统一的接口（如 `open()`、`read()`），隐藏硬件细节。
        
3. **安全性保障**
    - 内核会验证系统调用的参数，防止非法操作（如访问其他进程的内存）。

#### 常见的系统调用

* 设备管理
* 文件管理
* 进程控制
* 进程通信
* 内存管理
  
#### 系统调用与库函数

- 库是可重用的模块 `处于用户态`；系统调用的的执行权限是内核态
- 系统调用的性能开销较高，需要上下文切换；库函数无模式切换，开销较低

### 进程

#### 为什么要引入进程的概念

* 早期的计算机只支持`单道程序`（是指所有进程一个一个排队执行，A进程执行时，CPU、内存、I/O设备全是A进程控制的；等A进程执行完了，才换B进程，然后对应的资源比如CPU、内存这些才能换B用）
* 现代计算机是`多道程序` 执行，就是同时看起来有多个程序在一起执行，那每个程序执行都需要系统分配给它资源来执行，比如`CPU`、`内存`。
- 拿内存来说，操作系统要知道给A程序分配的内存有哪些，给B程序分配的内存有哪些，这些都要有记录，而这些记录就是进程的一部分，**进程的一大职责就是记录目前程序运行的状态**
- 系统为每个运行的程序配置一个数据结构，称为**进程控制块（PCB）**，用来描述进程的各种信息（比如代码段放在哪）


#### 进程的定义

**官方定义**

* IEEE/ISO 标准 -- `进程包括一个地址空间及其内部的一个或多个线程，以及这些线程所需的系统资源`
* Linux -- `进程是运行中程序的实例，包含其当前状态（内存、CPU寄存器、打开的文件等）`
* 经典教材 -- `进程本质上是执行中的程序，包括程序代码、当前活动（程序计数器、寄存器）、栈、数据段和堆`
* 操作系统概念 -- `进程是分时系统中的工作单元，由进程控制块（PCB）描述，包含进程状态、调度信息和内存管理数据`

**个人总结**
* 进程是运行中程序的动态执行实例
* 进程包括当前状态，调度信息和地址空间布局
* 还包括内部的一个或多个线程（一个进程中至少存在一个主线程），以及这些线程需要的系统资源
* 进程由进程控制块（PCB）进行描述

#### PCB ( Process Control Block ) 进程控制块

**作用**

- **标识进程**：为每个进程分配唯一的标识符，就像每个人都有自己的身份证号码一样，便于操作系统对不同进程进行区分和管理。
- **存储进程信息**：它包含了进程从创建到终止整个生命周期中的各种相关信息，是操作系统了解进程当前状态、运行情况以及进行资源分配和调度的依据。
- **支持进程调度**：操作系统根据 PCB 中记录的进程状态、优先级等信息，决定当前应该让哪个进程占用 CPU 资源，以及如何在不同进程之间进行切换，以实现多进程的并发执行。
- **实现进程控制**：通过对 PCB 中信息的修改和操作，操作系统可以对进程进行创建、暂停、恢复、终止等各种控制操作，从而有效地管理系统中的进程。

**组成**

- **进程标识信息**
    - **进程标识符（PID）**：是进程的唯一标识符，在进程被创建时，操作系统分配的一个独一无二的 PID，用于区分不同的进程。
    - **父进程 ID**：记录了该进程的父进程的 PID，通过这种方式可以形成进程的家族树结构，便于操作系统进行进程管理和资源分配。
    - **用户标识符 UID** ：用来表示这个进程`所属的用户`是谁
- **处理机状态信息**
    - **程序计数器（PC）**：指示进程即将执行的下一条指令的地址，它记录了进程在程序执行过程中的位置，确保进程能够按照正确的顺序执行指令。
    - **寄存器值**：包括通用寄存器、状态寄存器等的值。这些寄存器中存储了进程在运行过程中的中间结果、操作数以及处理器的状态信息等，当进程被暂停或切换时，需要将这些寄存器的值保存到 PCB 中，以便后续恢复进程执行时能够还原现场，继续正确执行。
- **进程控制信息**
    - **进程状态**：用于描述进程当前所处的状态，如就绪态、运行态、阻塞态等。操作系统根据进程状态来决定是否将进程调度到 CPU 上执行，以及如何处理处于不同状态的进程。
    - **优先级**：表示进程相对于其他进程的重要性和执行顺序的先后。优先级高的进程通常会优先获得 CPU 资源，以便更快地执行。
- **资源分配清单**：记录了进程所占用的各种系统资源，如内存空间、打开的文件、占用的设备等。这有助于操作系统在进程运行过程中进行资源管理和分配，防止资源冲突和浪费。
    - **程序段指针**：是指当前进程的程序在`内存的什么地方`
    - **数据段指针**：是指当前进程的数据在`内存的什么地方`
    - **键盘**：是指进程被`分配得到的I/O设备`
    - **鼠标**：是指进程被`分配得到的I/O设备`

#### 进程的组织

> 进程的组织是指操作系统如何对进程进行管理和安排，以便有效地利用系统资源并实现多进程并发执行。通常，进程的组织涉及到进程的状态、队列和层次结构等方面

#### 进程的状态

> `进程是程序的一次执行。`在这个执行过程中，有时进程正在`被CPU处理`，有时又需要`等待CPU服务`，可见，进程的 状态是会有各种变化
> 为了方便对各个进程的管理，操作系统需要将进程合理地划分为几种状态

1. **创建态**：当一个程序被启动或一个进程被创建时，进程处于创建态。此时，操作系统会为进程分配资源，如内存空间、进程控制块（PCB）等，并对进程进行初始化，包括设置进程的初始状态、分配进程 ID 等。
2. **就绪态**：进程已经获得了除 CPU 之外的所有必要资源，准备好运行，只要得到 CPU 资源，就可以立即执行。处于就绪态的进程会被放入就绪队列中，等待操作系统的调度。
3. **运行态**：进程正在 CPU 上执行。在单 CPU 系统中，任何时刻最多只有一个进程处于运行态；在多 CPU 系统中，可能有多个进程同时处于运行态。处于运行态的进程会占用 CPU 资源，执行其程序代码。
4. **阻塞态**：也称为等待态。进程因等待某个事件的发生而暂时无法继续执行，如等待 I/O 操作完成、等待获取某个资源、等待信号量等。此时，进程会放弃 CPU 资源，进入阻塞队列，直到所等待的事件发生，才会转换到就绪态。
5. **终止态**：进程完成了其任务，或者因出现错误等原因被操作系统终止。处于终止态的进程不再占用系统资源，操作系统会回收其 PCB 以及所占用的其他资源，如内存、打开的文件等。

#### 进程状态的转换

> 进程的状态不是一成不变的

![](计算机基础知识/进程状态.jpg)

**注意**
* 不能由阻塞到运行 -- 因为阻塞态是进程主动请求的；必然需要运行时才能发出这种请求

#### 原语

> 以上的这些进程状态的转换是如何实现的呢，这就要引出下一个角色了，叫`原语

**什么是原语**
* 原语是一种特殊的程序段
* 具有`原子性`，即它在执行过程中不能被中断，要么全部执行完成，要么完全不执行

##### 原语的特点

* **原子性**：这是原语最主要的特点，保证了原语操作的完整性和一致性
`例如，在对进程状态进行改变时，如将进程从就绪态变为运行态，使用原语可以确保这个操作不会被其他操作中断，避免出现进程状态不一致的情况`

* **不可分割性**：原语在执行过程中不能被分割成更小的部分来执行，它是一个不可分割的整体
`这就保证了原语所执行的操作是一个完整的逻辑单元，不会因为中断而导致部分操作执行，部分操作未执行的情况`

##### 原语的类型

- **进程控制原语**：用于对进程进行管理和控制，如`创建原语、撤销原语、阻塞原语和唤醒原语`等 
  1. 创建原语用于创建一个新的进程，为其分配资源并初始化进程控制块
  2. 撤销原语用于终止一个进程，回收其占用的资源
  3. 阻塞原语用于将进程从运行态转换为阻塞态，使其等待某个事件的发生
  4. 唤醒原语则用于将阻塞态的进程唤醒，使其转换为就绪态。
- **资源管理原语**：用于对系统资源进行管理和分配。如`申请资源原语和释放资源原语`
  1. 申请资源原语用于进程向系统申请所需的资源，如内存、设备等
  2. 释放资源原语用于进程在使用完资源后，将资源归还给系统，以便其他进程可以使用

##### 原语是怎样保证不可中断的？

原语采用`关中断指令`和`开中断指令`实现

- 首先执行关中断指令
- 然后外部来了中断信号，不予以处理
- 等到开中断指令执行后，其他中断信号才有机会处理

#### 进程的通信

##### 概念

因为进程是`分配系统资源的单位`（包括内存地址空间），每个进程都有自己独立的内存空间和执行上下文（即进程隔离）
进程通信允许这些独立的进程相互传递信息、共享资源或协调行为，就像不同的人通过语言、书信或电话进行交流一样

**作用**
* 资源共享
* 数据交换
* 模块化设计
* 并发协作，提高效率

##### 通信方式

> 进程通信方式可分为**共享内存**、**消息传递**、**管道**和**信号量**四大类

* **共享内存/共享存储** -- 操作系统就提供的一个内存空间让彼此都能访问，这就是共享存储的原理
* **信息传递** -- 操作系统就提供的一个内存空间让彼此都能访问，这就是共享存储的原理
* **管道** -- 一种特殊的文件，用于连接一个进程的输出和另一个进程的输入，数据单向流动
* **信号** -- 一种异步通信机制，用于通知进程发生了某个事件（如键盘中断`Ctrl+C`）


#### 进程的同步与互斥

##### 同步

> **同步**是指多个进程中发生的事件存在某种先后顺序。即某些进程的执行必须先于另一些进程

比如说`进程A`需要从缓冲区读取`进程B`产生的信息，当缓冲区为空时，`进程B`因为读取不到信息而被阻塞。而当`进程A`产生信息放入缓冲区时，`进程B`才会被唤醒
##### 互斥

> **互斥**是指多个进程不允许同时使用同一资源。当某个进程使用某种资源的时候，其他进程必须等待

比如`进程B`需要访问打印机，但此时`进程A`占有了打印机，`进程B`会被阻塞，直到`进程A`释放了打印机资源,进程B才可以继续执行
### 线程

#### 线程的定义

* 线程是操作系统能够进行运算调度的最小单位
* 它被包含在进程之中，是进程中的实际运作单位
* 一个进程可以拥有多个线程，这些线程共享进程的资源，如内存空间、打开的文件等
* 每个线程都有自己独立的程序计数器、寄存器和栈等

#### 线程的作用

- **提高程序并发性**：在一个进程内，多个线程可以同时执行不同的任务，从而提高程序的整体执行效率。例如，在一个图形界面应用程序中，一个线程可以负责处理用户界面的交互，另一个线程可以同时进行数据的加载或计算，这样可以让用户在等待数据处理的同时仍然能够与界面进行交互，提高用户体验。
- **资源共享与协作**：同一进程内的线程共享进程的资源，这使得它们之间的通信和协作变得更加容易和高效。线程可以方便地访问和修改进程中的共享数据，共同完成复杂的任务。例如，在一个多线程的服务器程序中，多个线程可以共享服务器的网络连接资源，同时处理不同客户端的请求。
- **简化程序结构**：将一个复杂的任务分解为多个线程来执行，可以使程序的结构更加清晰，易于理解和维护。每个线程可以专注于完成一个特定的子任务，降低了程序的复杂度。

### 内存

#### 内存的概念

**定义**
内存是计算机中用于暂时存储数据和程序的硬件设备，它充当着 CPU 与外部存储设备（如硬盘、光盘等）之间的桥梁，用于快速存储和读取数据，以支持计算机的高效运行
程序执行前需要先放到内存中才能被CPU处理

**作用**
- **数据存储**：在计算机运行过程中，操作系统、应用程序以及正在处理的数据都临时存储在内存中。例如，当打开一个文档进行编辑时，文档的内容会从硬盘加载到内存中，以便 CPU 能够快速访问和处理。
- **数据交互**：内存是 CPU 与其他硬件设备进行数据交互的场所。CPU 从内存中读取指令和数据进行处理，然后将处理结果写回内存。同时，内存也与硬盘、显卡等设备进行数据交换，确保整个计算机系统的协调运行

**分类**
* 随机存取存储器
* 只读存储器


#### CPU如何区分执行程序的数据在内存的什么地方

是通过给`内存的存储单元编址`实现的。（存储单元一般是以字节为单位）

#### 内存管理

> 内存管理主要分为**连续分配**与**非连续分配**

**连续分配**

连续分配是指为进程分配一组连续的内存空间。在这种方式下，进程所需的内存空间在物理内存中是连续的一块区域

* 实现简单，地址转换方便
* 容易产生内存碎片，导致内存空间的浪费，降低内存利用率
  
**非连续分配**

非连续分配允许将进程的地址空间分散地存储在不连续的内存块中，通过一定的地址转换机制来实现对进程内存的访问

* 有效解决了内存碎片问题，提高了内存利用率
* 地址转换过程相对复杂，需要额外的硬件支持

### 文件管理

**什么是文件？**

文件是计算机系统中用于存储和组织数据的一种抽象概念和实体
文件是由相关数据组成的具有一定名称的集合
#### 文件的属性

- 文件名。即文件的名字，需要注意的是，同一目录下`不允许`有重名的文件。
- 标识符。操作系统用于区分各个文件的一种`内部的名称`。
- 类型。文件的类型。
- 位置。文件`存放的路径`，同时也是在硬盘里的位置（需要转换成[物理硬盘](https://zhida.zhihu.com/search?content_id=117221738&content_type=Article&match_order=1&q=%E7%89%A9%E7%90%86%E7%A1%AC%E7%9B%98&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NDcyODQ5OTcsInEiOiLniannkIbnoaznm5giLCJ6aGlkYV9zb3VyY2UiOiJlbnRpdHkiLCJjb250ZW50X2lkIjoxMTcyMjE3MzgsImNvbnRlbnRfdHlwZSI6IkFydGljbGUiLCJtYXRjaF9vcmRlciI6MSwiemRfdG9rZW4iOm51bGx9.NoXbMZzi1rWmpKP1pyWmYJ-KO54V-CNh87WM6T6CKkw&zhida_source=entity)上的地址）
- 创建时间、上次修改时间、文件所有者就是字面意思。
- 保护信息。比如对这个文件的`执行权限`，是否有删除文件权限，修改文件权限等等。

#### 文件的类型

> 文件内部数据的组织方式决定了文件的逻辑结构，主要分为有结构文件和无结构文件

* **有结构文件/记录文件**
  1. 它是由一组相似的记录组成，每个记录由若干个数据项组成
  2. 记录是文件中`具有独立逻辑含义的最小数据单位`，数据项则是`构成记录的基本元素`

* **无结构文件/流式文件**
  1. 它将文件中的数据看作是一个连续的字节流，没有明显的记录边界和结构
#### 文件的结构

* **逻辑结构**：在用户看来，文件内部的数据是如何组织起来的
* **物理结构**：是在操作系统看来，文件是如何保存在外存，比如`硬盘`中的

##### 逻辑结构

**有结构文件的四种逻辑结构**
* 顺序文件
* 索引文件
* 顺序索引文件
* 直接文件/哈希文件

**无结构文件的逻辑结构**

无结构文件的组织方式相对简单，数据按照写入的先后顺序依次存储在文件中
操作系统只负责管理文件的存储空间，对文件中的数据内容不做任何解释和处理

#### 文件控制块 FCB

> **文件控制块（File Control Block，FCB）** 是操作系统为管理文件而设置的数据结构
> 它包含了文件的相关信息，用于实现对文件的各种控制和操作

#### 文件目录

> 文件目录是文件系统中**用于组织和管理文件的一种数据结构**
> 它就像是一个文件的 “索引” 或 “目录表”，帮助用户和操作系统**快速定位和访问文件**

**与FBC的关系**

* **关联方式**：文件目录中的每个目录项都与一个 FCB 相关联。通常，目录项中会包含一个指向对应 FCB 的指针（或索引），通过这个指针，操作系统可以快速找到文件的 FCB，从而获取文件的详细信息，如文件的物理位置、存取权限、使用信息等
* **相互作用**：文件目录为用户和操作系统提供了一种方便的文件查找和管理方式，而 FCB 则存储了文件的具体属性和控制信息

#### 文件存储空间管理

> 文件存储空间管理是操作系统对存储设备上的空间进行组织、分配和回收的过程
> 目的是高效利用存储空间，方便文件的存储和访问

**算法**
* 空闲表法
* 空闲链表法

**回收磁盘块**
如何回收磁盘块呢，主要分为以下4中情况

- 回收区的前后没有相邻空闲区
- 回收区前后都是空闲区
- 回收区前面是空前去
- 回收区后面是空闲区

#### 文件共享

**文件共享分为两种**
* 基于索引结点的共享方式（硬连接）
* 基于符号链的共享方式（软连接）

#### 文件保护

操作系统需要保护文件的安全，一般有如下3种方式：

- 口令保护。是指为文件设置一个`“口令”`（比如123），用户请求访问该文件时必须提供对应的口令。口令一般放在文件对应的`FCB或者索引结点`上。
- 加密保护。使用某个`"密码"`对文件进行加密，在访问文件时需要提供`正确的“密码”`才能对文件进行正确的解密。
- 访问控制。在每个文件的FCB或者索引节点种增加一个`访问控制列表`，该表中记录了各个用户可以对该文件执行哪些操作。


### I/O设备

**什么是I/O设备**

I/O就是`输入输出`(Input/Output)的意思
I/O设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备
属于计算机中的硬件部件

**分类 -- 按照使用特性**
* 人机交互类设备，这类设备传输数据的速度慢
* 存储设备，这类设备传输数据的速度较快
* 网络通信设备，这类设备的传输速度介于人机交互设备和存储设备之间

**I/O控制器**

CPU无法直接控制`I/O设备的机械部件`，因此I/O设备还要有一个电子部件作为`CPU`和`I/O设备`机械部件之间的`“中介”`，用于实现CPU对设备的控制。这个电子部件就是`I/O控制器`

**I/O控制方法**
* 这里我们指讲一下目前比较先进的方式，通道控制方式。  
    
- 通道可以理解为一种`“弱鸡版CPU”`。通道可以识别并执行一系列通道指令
- 通道最大的优点是极大的`减少了CPU的干预频率`，`I/O设备`完成任务，通道会向CPU发出`中断`，不需要轮询来问I/O设备是否完成CPU下达的任务。


## 计算机网络

### HTTP/HTTPS

### TCP/UDP 

### DNS/CDN

### Web安全

#### XSS

#### CSRF

#### CSP

#### 中间人攻击

### Web性能优化

### WebSocket

## RESTful API

### REST是什么

> REST（Representational State Transfer）是一种基于 HTTP 协议的软件架构风格，其核心思想是**资源为中心**，通过统一的接口操作资源状态

1. **客户端-服务器分离**（Client-Server）
    - 前后端解耦，前端专注 UI，后端专注数据与业务逻辑。
        
2. **无状态**（Stateless）
    - 每个请求必须包含所有必要信息（如 Token），服务端不存储会话状态。
        
3. **可缓存**（Cacheable）
    - 响应需明确标识是否可缓存（如 `Cache-Control` 头）。
        
4. **统一接口**（Uniform Interface）
    - 资源标识（URI）、资源操作（HTTP 方法）、自描述消息（HATEOAS）。
        
5. **分层系统**（Layered System）
    - 客户端无需关心中间层（如 CDN、负载均衡）。
        
6. **按需代码**（Code-On-Demand，可选）
    - 服务端可返回可执行代码（如 JavaScript）扩展客户端功能。


### RESTful API设计规范

#### 1. 资源（Resource）与 URI 设计

- **资源命名**：
    - 使用名词（而非动词），表示资源实体，如 `/users`、`/articles`。
    - 复数形式保持统一，避免混用（如 `/users` 而非 `/user`）。
        
- **URI 层级**：
    - 表示资源关系：`/users/{userId}/orders`（用户的所有订单）。
        
- **避免冗余**：
    - 错误示例：`/getUsers`（动词冗余），正确示例：`GET /users`。
#### 2. HTTP 方法语义化

|**方法**|**语义**|**幂等性**|**示例**|
|---|---|---|---|
|`GET`|获取资源|是|`GET /users/1`|
|`POST`|创建资源|否|`POST /users`|
|`PUT`|全量更新资源|是|`PUT /users/1`|
|`PATCH`|部分更新资源|否|`PATCH /users/1`（更新邮箱）|
|`DELETE`|删除资源|是|`DELETE /users/1`|

#### 3. 状态码（Status Codes）

- **2xx 成功**：
    - `200 OK`：通用成功。
    - `201 Created`：资源创建成功（配合 `Location` 头返回新资源 URI）。
- **4xx 客户端错误**：
    - `400 Bad Request`：请求参数错误。
    - `401 Unauthorized`：未认证。
    - `404 Not Found`：资源不存在。
- **5xx 服务端错误**：
    - `500 Internal Server Error`：通用服务端错误。
#### 4. 请求与响应设计

- **请求头**：
    - `Accept`：客户端期望的响应格式（如 `application/json`）。
    - `Authorization`：认证信息（如 `Bearer <token>`）。
        
- **响应体**：
    - 统一数据格式（如 JSON）：
    - 错误响应示例：
#### 5. 版本控制

- **URI 路径**：`/v1/users`（显式版本，推荐）。
- **请求头**：`Accept: application/vnd.example.v1+json`（媒体类型版本）。
    

#### 6. 过滤、分页与排序
- **过滤**：`GET /users?role=admin`。
- **分页**：`GET /users?page=2&limit=10`。
- **排序**：`GET /users?sort=-created_at`（`-` 表示降序）。

### 面试问题

1. **RESTful 和 RPC 的区别？**
    - RESTful 以资源为中心，RPC 以动作为中心（如 `/getUser`）。
        
2. **PUT 和 PATCH 的区别？**
    - PUT 全量更新，PATCH 部分更新。
        
3. **如何设计一个 RESTful 的批量删除接口？**
    - `DELETE /users?ids=1,2,3` 或 `POST /users/batch-delete`（Body 传 ID 数组）。
        
4. **什么是 HATEOAS？**
    - 超媒HATEOAS 即超媒体作为应用状态引擎（Hypermedia as the Engine of Application State）
    - 是 RESTful 架构中的一个重要原则
    - 它的核心概念是将`应用程序的状态转换通过超媒体链接进行驱动`，`使得客户端能够通过服务器返回的超媒体信息来了解如何与应用程序进行交互`，而无需事先知道所有可能的操作和状态转换
    - 响应中返回资源关联链接
```json
{
  "data": { "id": 1 },
  "links": { "self": "/users/1", "orders": "/users/1/orders" }
}
```


