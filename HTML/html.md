## HTML
### 如何理解HTML语义化
* 让人更容易读懂
* 让搜索引擎更加容易读懂，有助于爬虫抓取更多有效的信息，爬虫依赖于**标签**来确定上下文和各个关键字的权重（SEO）
* 在没有CSS样式下，页面内也能呈现出很好的内容结构与代码结构
### script标签中 defer 和 async的区别
```html
<script src="xxx"></script>
<script async src="xxx"></script>
<script defer src="xxx"></script>
```
#### script（默认同步模式，也称阻塞模式）
* **立即加载 立即执行**
* **加载和执行都 ==不同步== ，会打断页面解析 影响页面显示**
* 只有下载好并执行完脚本才会继续解析HTML
![](images/同步模式.jpg)
##### 使用时机
浏览器需要采用同步模式，因为一般加载的JS文件中有对DOM元素的操作，如 重定向等默认行为，所以**同步才是最安全的**
##### 把script标签放到body标签前的意义
一般来说，script标签都是放在header中来引用。而把它放到body之前，可以使得==js文件在 页面最后 加载==，尽量减少阻塞页面的渲染/显示 使页面先渲染出来

#### async script（异步加载，不是异步执行，仅限外部脚本）
* **加载并行** 不影响页面解析
* 加载/下载完立即执行
* **执行不并行** 可能会打断页面解析
![](images/异步模式.jpg)
> **async表示异步**
    当浏览器遇到带有async属性的script时，表示该脚本的网络请求是异步的，不会阻塞浏览器解析HTML，一旦网络请求回来之后，如果此时HTML还没有解析完，浏览器就会暂停解析，先让JS引擎执行代码，执行完毕后再进行解析


* async是不可控的，因为执行时间不确定，在异步JS脚本中可能获取得到某个DOM元素也可能获取不到
* 如果存在多个async，它们的执行顺序也不确定，完全依赖网络传输结果


解析HTML过程中进行脚本的异步下载，下载成功立马执行，有可能会阻断HTML的解析
#### defer script（延迟执行，不是延迟加载）
* **获取并行** 不影响页面解析
* **执行不并行** 在页面解析完毕后执行，不影响页面解析
* 加载和执行都不会打断页面解析
![](images/延迟执行.jpg)
> **defer表示延迟**
>     当浏览器遇到带有defer属性的script时，获取该脚本的网络请求也是异步的，不会阻塞浏览器解析HTML,
完全不会阻碍script的解析，解析完成之后再按照顺序执行脚本

##### 使用时机
* 有些JS代码并不是页面初始化时就立即需要的，这种暂时用不上的代码就在需要的时候或者稍后通过JS的控制来执行 同样不会影响页面解析
* 比如**图片的延迟加载**：当图片出现在浏览器的可视化区域才加载显示图片，在滚动条尚未滚动到的区域内的图片元素则在稍后才进行渲染
##### 延迟加载
除了延迟执行 还可以设置延迟加载
* 方法 -- 将script标签放在文档的底部（body前面）这样文档按顺序加载和解析的时候到最后才会加载这些代码片段
##### 冲突事项
用了defer不要使用document.write()

#### 同步加载 异步加载 延迟执行的联系与区别
##### 同时指定 async,defer属性（行为回退，避免阻塞行为）
> **行为回退**：即使指定了async属性，也可以指定defer属性
     回退到延迟执行：使仅支持 延迟执行defer 而不支持 异步加载async的遗留浏览器 退回到 延迟执行defer行为 而不是默认的阻塞行为

##### 多个脚本的执行顺序
###### 同步加载
* 按顺序：放置在 head标签 内 
   * ==会阻塞body的渲染 会出现白屏 按照顺序立即执行几个脚本文件==
* 按顺序：放置在 body标签 底部
   * ==等body内的内容渲染完毕后再按顺序执行JS 没有兼容性问题 没哟白屏问题 没有执行顺序问题==
   * ==推荐写法）==
###### 异步加载
*  放置在head标签并使用async
   * ==先加载完毕的 先执行== 并不会按JS文件顺序 谁快谁先上
###### 延迟执行
* 放置在head标签并使用defer
  * 按顺序执行
  * **H5规范要求** -- 脚本按照它们出现的先后顺序执行 第一个defer延迟脚本先于第二个执行 而这两个脚本会先于DOMContentLoaded事件执行
  * 但是 在实际应用，延迟执行的脚本不一定按顺序执行，也不一定会在DOMContentLoaded时间触发前执行 因此==最好只包含一个延迟脚本==
![](images/延迟执行顺序.jpg)
###### 异步加载 & 延迟执行
* 放置在head标签内 并同时使用async和defer
  * 表现和async一致
  * 不支持async加载的但支持defer的 表现和defer一致（行为回退）**推荐**

### 从浏览器地址栏输入url到请求返回发生了什么
#### 开发和运维角度方向
* DNS解析 -- 将域名解析成IP地址
* TCP连接 -- TCP三次握手
* 发送HTTP请求
* 服务器处理请求并返回HTTP报文
* 浏览器解析渲染页面
* 断开连接：TCP四次挥手
##### 什么是URL
> Uniform Resource Locator -- 统一资源定位符 用于定位互联网上资源 俗称网址

```
scheme://host.domain:port/path/filename?query=value#fragment
```

| 元素       | 定义                                                                  |
| -------- | ------------------------------------------------------------------- |
| scheme   | 定义因特网服务的类型，常见的协议有：http,https,ftp,file。其中常见的类型是http，而https是进行机密的网络传输 |
| host     | 定义域主机（http的默认主机是www）                                                |
| domain   | 定义因特网域名，比如baidu.com                                                 |
| port     | 定义主机上的端口号（http的默认端口号是80）                                            |
| filename | 定义文档/资源的名称                                                          |
| query    | 即查询参数                                                               |
| fragment | # 后面的hash值，一般用来定位到某个位置                                              |
##### DNS域名解析
在浏览器输入网址后，首先要进行域名解析，因为浏览器并不能直接通过域名找到对应的服务器，而是要通过IP地址
###### IP地址
IP地址是**互联网协议地址**，是IP Address 的缩写，IP地址是IP协议提供的一种统一的地址格式
它是互联网上的每一个网络和每一台主机分配的一个逻辑地址，以此来屏蔽物理地址的差异
###### 域名解析
DNS协议提供通过域名查找IP地址，或逆向从IP地址反查域名的服务
DNS协议是一个**网络服务器**，我们的域名解析简单俩说就是在DNS上记录一条信息记录
###### 浏览器如何通过域名去查询URL对应的IP呢
DNS域名解析分为递归查询和迭代查询，现一般为迭代查询
###### DNS的优化与应用
* **DNS缓存** 
* **DNS负载均衡(DNS重定向)** 
* **CDN** -- 是利用DNS的重定向技术，CDN节点的服务器负责响应用户的需求，提供所需的内容
* **dns-prefetch** -- 一种DNS预解析技术，当用户浏览网页时，浏览器会在加载网页时对网页中的域名进行解析缓存，这样当再次点击当前网页中的连接时就不需要进行DNS的解析，减少用户等待时间，提高用户体验
###### TCP/IP四层模型
![](images/四层模型.jpg)

##### TCP三次握手
##### 发送HTTP请求
##### 服务求处理请求并返回HTTP报文
##### 浏览器解析渲染页面
###### 浏览器的主要构成
* 用户界面 
* 浏览器引擎
* 渲染引擎
* 网络
* JS解释器
* UI后端
* 数据存储
###### 多进程的浏览器
浏览器是多进程的，有一个主控进程，以及每一个tab页面都会新开一个进程
进程可能包括：主控进程，插件进程，GPU，tab页(浏览器内核)等
###### 浏览器内核拿到内容后，渲染步骤大致分为：
**1. 解析HTML 生成DOM树**
* 规则简述
```
Bytes -> Characters -> tokens -> nodes -> DOM
```
![](images/解析HTML生成DOM树.jpg)
* 关键步骤
```
* Conversion转换：浏览器将获得的HTML内容基于他的编码转换为单个字符
* Tokenizing分词：浏览器按照HTML标准化将这些字符转换为不同的标记token，每个token有自己独特的含义以及规则集
* Lexing词法分析：分词的结果是得到一堆的token，此时将他们转换为对象，这些对象分别定义他们的属性和规则
* DOM构建：因为HTML标记定义的就是不同标签之间的关系，这个关系就像一个树形结构一样
```
**2. 解析CSS 生成CSS规则树**
类似
**3. 合并DOM树和CSS规则 生成render树**
一般来说，渲染树和DOM树相对应，但不是严格意义上的一一对应，因为有一些不可见的DOM元素不会插入到渲染树中，如head这种不可见的标签或者添加了display:none属性等
**4. 布局render树（Layout/reflow） 负责各元素尺寸和位置的计算**
布局：通过渲染树中渲染对象的信息，就算出每一个渲染对象的位置和尺寸
* Layout，也称Reflow，即回流，一般意味着元素的 ==内容，结构，位置或者尺寸== 发生了变化，需要 ==重新计算和渲染树==
**5. 绘制render树（paint） 绘制页面像素信息**
绘制：系统会遍历呈现树，并调用呈现的"paint"方法，将呈现器的内容显示在屏幕上
* Repaint，即重绘，意味着元素发生的变化只是影响了元素的一些外观之类的时候，此时只需要应用新样式绘制这个元素即可
##### 断开连接 -- 四次挥手

