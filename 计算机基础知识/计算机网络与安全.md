## 从输入URL到页面加载发生了什么

### 1. URL解析

**地址解析：** 
判断输入的是一个合法的 URL 还是一个待搜索的关键词；根据输入的内容进行自动完成，字符编码等操作

**HSTS**( HTTP Strict Transport Security )
由于安全隐患，会使用 HSTS 强制客户端使用 HTTPS 访问页面

**其他操作**
浏览器还会进行一些额外的操作，比如安全检查、访问限制

**检查缓存**
浏览器查找当前URL是否存在缓存，并比较缓存是否过期

#### HSTS

**原理**
- 在服务器响应头中添加 `Strict-Transport-Security`，可以设置 `max-age`
- 用户访问时，服务器种下这个头
- 下次如果使用 http 访问，只要 max-age 未过期，客户端会进行内部跳转，可以看到 307 Redirect Internel 的响应码
- 变成 https 访问源服务器

**作用**
这个过程有效避免了中间人对 80 端口的劫持；有效防范中间人攻击
同时也为浏览器节省来一次 302/301 的跳转请求

**问题**
- HSTS 没法处理纯 IP 的请求，比如 `http://2.2.2.2` ， 即便响应头中设置了 STS，浏览器也不会理会
- HSTS 只能在`80 和 443 端口之间切换`，如果服务是 8080 端口，即便设置了 STS，也无效
- 如果`浏览器证书错误`，一般情况会提醒存在安全风险，然是依然给一个链接进入目标页，而 HSTS 则没有目标页入口，所以一旦证书配置错误，就是很大的故障了
- 如果服务器的 HTTPS 没有配置好就开启了 STS 的响应头，并且还设置了很长的过期时间，那么在你服务器 HTTPS 配置好之前，用户都是没办法连接到你的服务器的，除非 max-age 过期了。
- HSTS 能让你的网站在 ssllab 上到 A+（这不是坑）
#### 缓存

##### 缓存类型
* **强制缓存**，通过`Expires或Cache-Control：max-age`判断该缓存是否过期
  1. 未过期：直接使用该资源；如果Expires和max-age同时存在，则被Cache-Control的max-age覆盖
  2. 过期：**协商缓存**

* **协商缓存**，请求头部带上相关信息如`if-none-match（Etag）`与`if-modified-since(last-modified)`，验证缓存是否有效
  1. 若有效则返回状态码为`304`，
  2. 若无效则重新返回资源，状态码为`200`

##### 检查缓存流程

*  是否过期？（强制缓存，通过`Expires或Cache-Control：max-age`判断该缓存是否过期）
   1. 是 -- 判断Etag( `向服务器请求if-none-match` )或者Last-Modified( `向服务器请求if-modified-since )
     1.1 Etag与Last-Modified都不一致 -- 向服务器请求
     1.2 服务器返回200( `请求响应，协商缓存` )304( `读取本地缓存` )
   2. 否 -- 向服务器请求；请求响应后进行协商缓存

### 2. DNS域名解析

> 　域名是与IP地址的一个映射。域名解析的过程实际是`将域名还原为IP地址的过程`

**具体流程**
* 首先检查`本地hosts文件`是否有这个`网址映射关系`，如果有就调用这个IP地址映射，完成域名解析
* 如果没找到则会查找`本地DNS解析器缓存`，如果查找到则返回
* 如果还是没有找到则会查找`本地DNS服务器`，如果查找到则返回
* 最后进行迭代查询与递归查询

### 3. TCP连接 -- 三次握手

#### TCP协议

> TCP( Transmission control protocol )即**传输控制协议**，是一种**面向连接**、**可靠的**数据传输协议，它是为了在不可靠的互联网上提供可靠的端到端字节流而专门设计的一个传输协议

- **面向连接**：数据传输之前客户端和服务器端必须建立连接
- **可靠的**：数据传输是有序的 要对数据进行校验

#### 三次握手

> 在通过第一步的DNS域名解析后，获取到了服务器的IP地址
> 在获取到IP地址后，便会开始建立一次连接，这是由TCP协议完成的，主要**通过三次握手进行连接**

> 为了保证客户端和服务器端的可靠连接，TCP建立连接时**必须**要进行三次会话，也叫TCP三次握手，**进行三次握手的目的是为了确认双方的接收能力和发送能力是否正常**

**具体流程**

![](计算机基础知识/TCP三次握手.jpg)

1. 第一次握手： 建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认
2. 第二次握手： 服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态
3. 第三次握手： 客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。

完成三次握手，客户端与服务器开始传送数据。

#### 三次握手的目的

**三次握手之所以是三次，是保证client和server均让对方知道自己的接收和发送能力没问题而保证的最小次数。两次不安全，四次浪费资源**

- 第一次握手： 客户端向服务器端发送报文  
    `证明客户端的发送能力正常`
- 第二次握手：服务器端接收到报文并向客户端发送报文  
    `证明服务器端的接收能力、发送能力正常`
- 第三次握手：客户端向服务器发送报文  
    `证明客户端的接收能力正常`

### 4. 浏览器向服务器发送HTTP请求

> 完整的HTTP请求包含请求起始行、请求头部、请求主体三部分

### 5. 服务器处理请求

接受 TCP 报文后，会对连接进行处理，对HTTP协议进行解析（请求方法、域名、路径等），并且进行一些验证：

- 验证是否配置虚拟主机
- 验证虚拟主机是否接受此方法
- 验证该用户可以使用该方法（根据 IP 地址、身份信息等）

### 6. 浏览器接收响应

浏览器接收到来自服务器的响应资源后，会对资源进行分析。

首先查看 Response header，**根据不同状态码做不同的事**（比如上面提到的重定向）。

如果响应资源进行了压缩（比如 gzip），还需要进行解压。
然后，对响应资源做缓存。

接下来，根据响应资源里的 MIME 类型去解析响应内容（比如 HTML、Image各有不同的解析方式）

### 7. 页面渲染

**浏览器内核的工作**

### 8. 关闭TCP连接或者继续保持连接

#### 通过四次挥手关闭连接

![](计算机基础知识/四次挥手.png)

**第一次挥手** 
1. 客户端发出连接释放报文，并且停止发送数据
2. 释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1）
3. 此时，客户端进入FIN-WAIT-1（终止等待1）状态

**第二次挥手** 
1. 服务器端接收到连接释放报文后，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v
2. 此时，服务端就进入了CLOSE-WAIT 关闭等待状态

**第三次挥手**
1. 客户端接收到服务器端的确认请求后，客户端就会进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文
2. 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。

**第四次挥手**
1. 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态
2. 但此时TCP连接还未终止，必须要经过2MSL后（最长报文寿命），当客户端撤销相应的TCB后，客户端才会进入CLOSED关闭状态
3. 服务器端接收到确认报文后，会立即进入CLOSED关闭状态，到这里TCP连接就断开了，四次挥手完成

**为什么客户端要等待2MSL？**  

主要原因是为了`保证客户端发送那个的第一个ACK报文能到到服务器，因为这个ACK报文可能丢失`
2MSL是`任何报文在网络上存在的最长时间`
超过这个时间报文将被丢弃，这样新的连接中不会出现旧连接的请求报文。

* MSL是Maximum Segment Lifetime英文的缩写


## cors跨域请求

### 同源政策

#### 什么是同源

> 如果两个页面的`协议`，`域名`和`端口`都相同，则两个页面具有**相同的源**

**例如** -- 对于该网址而言：`http://www.test.com/index.html`
* 协议：https
* 域名：www.test.com
* 端口：默认是80端口

若另一个网址的上述三个元素都相同，则说明它们**同源**

#### 什么是同源策略

> 同源策略（英文全称 Same origin policy）是**浏览器提供**的一个**安全功能**

**MDN官方所给概念：**
* 同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互
* 这是一个用于隔离潜在恶意文件的重要安全机制

**资源交互**
- 无法读取非同源网页的 `Cookie`、`LocalStorage` 和 `IndexedDB`
- 无法接触非同源网页的 `DOM`
- 无法向非同源地址发送 `AJAX` 请求

### 跨域

> 同源指的是两个 URL 的`协议`、`域名`、`端口`一致，反之，则是**跨域**

**出现跨域的根本原因**
* 浏览器的`同源策略`不允许非同源的 URL 之间进行资源的交互

**浏览器允许发起跨域请求，但是跨域请求回来的数据，会被浏览器拦截，无法被页面获取到**

#### 如何实现跨域数据请求

* 实现跨域数据请求方法有很多，比如`JSONP`、`CORS`、`postMessage`、`Websocket`、`Nginx反向代理`、`window.name + iframe` 、`document.domain + iframe`、`location.hash + iframe`等
* 其中最主要的三种解决方案，分别是 **JSONP** 和 **CORS** 和 **Nginx反向代理**


### 什么是cors

CORS是一个W3C标准，全称是"跨域资源共享"（Cross-origin resource sharing）
它允许浏览器向跨源服务器，发出`XMLHttpRequest`请求，从而克服了AJAX只能同源使用的限制

* CORS需要浏览器和服务器同时支持；目前所有浏览器都支持该功能，因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信

### 两种请求

> 浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）

#### 简单请求

**条件**
（1) 请求方法是以下三种方法之一：

- HEAD
- GET
- POST

（2）HTTP的头信息不超出以下几种字段：

- Accept
- Accept-Language
- Content-Language
- Last-Event-ID
- Content-Type：只限于三个值`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`

这是为了兼容表单（form），因为历史上表单一直可以发出跨域请求。AJAX 的跨域设计就是，只要表单可以发，AJAX 就可以直接发。

##### 基本流程

> 对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个`Origin`字段。

```http
GET /cors HTTP/1.1
Origin: http://api.bob.com
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
```

**代码说明**
* 上面的头信息中，`Origin`字段用来说明，本次请求`来自哪个源（协议 + 域名 + 端口）`
* 服务器根据这个值，决定是否同意这次请求

**服务器工作**

* 如果`Origin`指定的源，不在许可范围内，服务器会返回一个正`常的HTTP回应`
浏览器发现，这个回应的头信息没有包含`Access-Control-Allow-Origin`字段，就知道出错了，从而抛出一个错误，被`XMLHttpRequest`的`onerror`回调函数捕获
注意，**这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200**

* 如果`Origin`指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段

```http
Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Credentials: true
Access-Control-Expose-Headers: FooBar
Content-Type: text/html; charset=utf-8
```

##### 关于cookie

> 上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定`Access-Control-Allow-Credentials`字段

```http
Access-Control-Allow-Credentials: true
```

> 另一方面，开发者必须在AJAX请求中打开`withCredentials`属性。

```javascript
var xhr = new XMLHttpRequest();
xhr.withCredentials = true;
```

**例外**
但是，如果省略`withCredentials`设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭`withCredentials`

需要注意的是，如果要发送Cookie，`Access-Control-Allow-Origin`就不能设为星号，必须指定明确的、与请求网页一致的域名
同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的`document.cookie`也无法读取服务器域名下的Cookie


#### 非简单请求

> 对于非简单请求，会在正式通信之前，增加一次HTTP查询请求，称为`"预检"请求`（options）
> 用来判断当前网页所在的域名**是否在服务器的许可名单之中**

如果在许可名单中，就会发正式请求；如果不在，就会报跨越错误

### 与JSONP的区别

CORS与JSONP的使用目的相同，但是比JSONP更强大。

JSONP只支持`GET`请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据

## WebSocket

> WebSocket是HTML5提供的一种浏览器与服务器进行`全双工通讯`的网络技术，属于应用层协议，WebSocket没有跨域的限制

**解决问题**
WebSocket的出现，让服务器端可以主动向客户端发送信息
使得浏览器具备了实时双向通信的能力

**WebSocket基于TCP传输协议**
WebSocket基于TCP传输协议，并复用HTTP的握手通道。浏览器和服务器只需要建立一次http连接，两者之间就直接可以创建持久性的连接，并进行双向数据传输

**缺点**
websocket 不稳定，要建立心跳检测机制，如果断开，自动连接

## TCP与UDP

### 概念

**TCP协议：** TCP全称`传输控制`协议，对数据的传输进行控制
**UDP协议：** UDP全称`用户数据报`协议，是一种无连接的传输层协议，主要用于在计算机之间传输数据

### 相同点

> UDP协议和TCP协议都是**传输层协议**

* TCP（Transmission Control Protocol，传输控制协议）提供的是面向连接，可靠的字节流服务
* 即客户端和服务器交换数据前，必须现在双方之间建立一个TCP连接，之后才能传输数据
* 提供`超时重发，丢弃重复数据，检验数据，流量控制`等功能，保证数据能从一端传到另一端。

* UDP（User Data Protocol，用户数据报协议）是一个简单的面向数据报的运输层协议
* 它不提供可靠性，只是把应用程序传给IP层的数据报发送出去，但是不能保证它们能到达目的地
* 由于UDP在传输数据报前不用再客户和服务器之间建立一个连接，且没有超时重发等机制，所以`传输速度很快`

### 不同点

#### 面向对象
* TCP基于字节流
* UDP基于数据报

#### 连接与无连接
**TCP面向连接**
* TCP建立一个连接需要3次握手IP数据包，断开连接需要4次握手
* 另外断开连接时发起方可能进入TIME_WAIT状态长达数分钟（视系统设置，windows一般为120秒），在此状态下连接（端口）无法被释放

**UDP面向无连接**
* UDP不需要建立连接，可以直接发起
#### 传输可靠性

**TCP是可靠性连接**
* TCP利用握手、ACK和重传机制
1，校验和（校验数据是否损坏）；  
2，定时器（分组丢失则重传）；  
3，序列号（用于检测丢失的分组和重复的分组）；  
4，确认应答ACK（接收方告知发送方正确接收分组以及期望的下一个分组）；  
5，否定确认（接收方通知发送方未被正确接收的分组）；  
6，窗口和流水线（用于增加信道的吞吐量）。（窗口大小：无需等待确认应答而可以继续发送数据的最大值）

**UDP连接不可靠**
* UDP没有确认机制, 没有重传机制;
* 如果因为网络故障该段无法发到对方, UDP协议层也`不会给应用层返回任何错误信息`

#### 报头不同/有序性

* tcp的头部比20bytes，udp8byres

* UDP数据报最大长度64K（包含UDP首部），如果数据长度超过64K就需要`在应用层手动分包`，UDP无法保证包序，需要`在应用层进行编号`
* TCP利用seq序列号对包进行排序

#### 流量控制

* TCP有流量控制，UDP没有



### 应用场景

**- TCP应用场景：**  
    效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高
    举几个例子：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。
    
**- UDP应用场景：**  
    效率要求相对高，对准确性要求相对低的场景
    举几个例子：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）

## keep-alive持久连接

### HTTP短连接

> 众所周知，HTTP是短连接，client向server发送一个request，得到response后，连接就关闭。之所以这样设计使用，主要是考虑到实际情况

**实例**
例如，用户通过浏览器访问一个web站点上的某个网页，当网页内容加载完毕之后，用户可能需要花费几分钟甚至更多的时间来浏览网页内容，
此时完全没有必要继续维持底层连接。当用户需要访问其他网页时，再创建新的连接即可。

**HTTP连接的寿命**
* 因此，HTTP连接的寿命通常都很短。这样做的好处是，可以极大的减轻服务端的压力。一般而言，一个站点能支撑的最大并发连接数也是有限的
* 面对这么多客户端浏览器，不可能长期维持所有连接。每个客户端取得自己所需的内容后，即关闭连接，更加合理

### 什么是keep-alive

keep-alive 是客户端和服务端的一个约定

如果开启 keep-alive，则服务端在返回 response 后不关闭 TCP 连接；同样的，在接收完响应报文后，客户端也不关闭连接，发送下一个 HTTP 请求时会重用该连接

**使用方法**

* 在HTTP/1.0 -- 显式打开
```http
Connection: keep-alive
```

* HTTP/1.1 -- 默认打开，显示关闭
```http
Connection: close
```

### 为什么要引入keep-alive

> 通常一个网页可能会有很多组成部分，除了文本内容，还会有诸如：js、css、图片等静态资源，有时还会异步发起AJAX请求
> 
> 只有所有的资源都加载完毕后，我们看到网页完整的内容。然而，一个网页中，可能引入了几十个js、css文件，上百张图片，

如果每请求一个资源，就创建一个连接，然后关闭，代价实在太大了。

基于此背景，我们希望**连接**能够在**短时间**内得到复用，在加载同一个网页中的内容时，尽量的复用连接，这就是HTTP协议中keep-alive属性的作用

### 使用与否

keep-alive 技术创建的目的，就是能在多次 HTTP 之间重用同一个 TCP 连接，从而**减少创建/关闭多个 TCP 连接的开销（包括响应时间、CPU 资源、减少拥堵等）**

显然，**如果客户端和服务端的确需要进行多次通信，则开启 keep-alive 是更好的选择**，例如在微服务架构中，通常微服务的使用方和提供方会长期有交流。

**在一些 TPS/QPS 很高的 REST 服务中，如果使用的是短连接（即没有开启keep-alive），则很可能发生客户端端口被占满的情形**

### 如何处理

#### 客户端如何开启

现在我们用到的几乎所有工具都是默认开启长连接的：

- 对于**浏览器**而言，几乎你现在用的浏览器（包括 IE6）都默认使用 keep-alive 了。
- **Java8** 中的 **`HttpURLConnection`** 默认开启长连接，但是默认连接池中只保留 5 个长连接，如果同时超过 5 个线程在使用，则会创建新的连接，结束后多于 5 个的部分会被客户端主动关闭。
- **Apache `HttpClient`** 默认为每个地址保留 2 个长连接，连接池中最多共保留 20 个连接。
- **Python requests** 如果使用 session 则会默认开启长连接。

#### 服务端如何开启

不同的服务端对 keep-alive 的实现方式不同，就连 tomcat 不同的工作模式下，处理的方式也不同

### HTTP与TCP中的keep-alive的区别

* **HTTP协议(七层)** 的Keep-Alive意图在于**连接复用**，希望可以短时间内在同一个连接上进行多次请求/响应。**核心在于：时间要短，速度要快**
* **TCP协议(四层)** 的KeepAlive机制意图在于 **保活、心跳，检测连接错误**。 核心在于：**虽然频率低，但是持久**


### 关于阻塞

**注意：**
持久连接采用阻塞模式，下次请求必须等到上次响应返回后才能发起，如果上次的请求还没返回响应内容，下次请求就只能等着（就是常说的线头阻塞）


## HTTP&HTTPS

### HTTP 1,2,3的区别

#### 1与2的区别

1. **二进制传输**：HTTP/2 采用二进制格式传输数据，而非HTTP/1.x 里纯文本形式的报文 ，二进制协议`解析起来更高效`

2. **Header 压缩**
* HTTP/1.x的请求和响应头部带有大量信息，而且每次请求都要重复发送
* HTTP2在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键-值对，对于相同的数据，不再每次请求和响应发送

3. **多路复用**

* 指的是在一个 TCP 连接中可以发送多个请求
* 可以避免 HTTP 旧版本中的线头阻塞问题（下次请求必须等到上次响应返回后才能发起）

* 这样某个请求任务耗时严重，不会影响到其它连接的正常执行，极大的提高传输性能

在 HTTP/2 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。 帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流（即请求），通过重新排序还原请求

4. **服务端推送**： 这里的服务端推送，是指把客户端所需要的css/js/img资源伴随着index.html，一起发送到客户端，省去了客户端重复请求的步骤

#### 3的区别

* http 协议是应用层协议，都是建立在传输层之上的
* 2.0 和 1.0 都是基于 TCP 的
* **而 Http3.0 则是建立在 UDP 的基础上**

**3的新特性**
* 多路复用，彻底解决TCP中队头阻塞的问题  
* 集成了TLS加密功能  
* 向前纠错机制

#### 总结

1）HTTP/1.1有两个主要的缺点：**安全不足和性能不高**

2）HTTP/2完全兼容HTTP/1，**是“更安全的HTTP、更快的HTTPS"**，头部压缩、多路复用等技术可以充分利用带宽，降低延迟，从而大幅度提高上网体验

3）QUIC 基于 UDP 实现，是 HTTP/3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了**即快又可靠的协议**


### HTTPS

#### HTTP的弊端

> HTTP 之所以被 HTTPS 取代，最大的原因就是不安全

**不安全的原因**
* HTTP在传输数据的过程中，所有的数据都是明文传输，没有安全性而言
* 即使是MD5，SHA-1 之类的哈希算法并不能让 HTTP 变得更安全

**需求**
* 要想让 HTTP 更安全，只能使用真正的加密算法，因为加密算法可以用密钥加密或还原数据，只要确保密钥不被第三方获取，那就能确保数据传输的安全了
* 而这正是 HTTPS 的解决方案

#### 加密算法

> HTTPS 解决数据传输安全问题的方案就是使用加密算法，具体来说是混合加密算法
> 也就是**对称加密和非对称加密的混合使用**

##### 对称加密

> 加密和解密都是使用同一个密钥，
> 常见的对称加密算法有：DES，3DES，AES

**优点**
算法公开、计算量小、加密速度快、加密效率高，适合加密比较大的数据

**缺点**
1. 交易双方需要使用相同的密钥，也就无法避免密钥的传输，而密钥在传输过程中无法保证不被截获，`因此对称加密的安全性得不到保证`。
2. 每对用户每次使用对称加密算法时，都需要使用其他人不知道的惟一密钥，这会使得发收信双方所拥有的钥匙数量急剧增长，`密钥管理成为双方的负担`。对称加密算法在分布式网络系统上使用较为困难，主要是因为密钥管理困难，`使用成本较高`。

##### 非对称加密

> 就是加密和解密需要使用两个不同的密钥：公钥（public key）和私钥（private key）
> 公钥与私钥是一对，如果用公钥对数据进行加密，只有用对应的私钥才能解密；如果用私钥对数据进行加密，那么只有用对应的公钥才能解密

**优点**
算法公开，加密和解密使用不同的钥匙，私钥不需要通过网络进行传输，安全性很高

**缺点**
计算量比较大，加密和解密速度相比对称加密慢很多

#### 什么是HTTPS

**维基百科**

> HTTPS (Hypertext Transfer Protocol Secure) 是**基于 HTTP 的扩展**
> 用于计算机网络的安全通信，已经在互联网得到广泛应用
> 
> 在 HTTPS 中，原有的 HTTP 协议会得到 **TLS (安全传输层协议) 或其前辈 SSL (安全套接层) 的加密**
> 因此 HTTPS 也常指 HTTP over TLS 或 HTTP over SSL
> 
> **可见HTTPS 并非独立的通信协议，而是对 HTTP 的扩展，保证了通信安全**

**可以这样说：** HTTPS = HTTP + SSL/TLS

#### HTTPS原理解析

> HTTPS 的整个通信过程可以分为两大阶段：**证书验证**和**数据传输**阶段
> 数据传输阶段又可以分为**非对称加密**和**对称加密**两个阶段

**https采用非对称加密+对称加密，非对称加密来传递密钥；对称加密来加密内容**

**具体流程**
**1. 非对称加密**
* 客户端请求 HTTPS 网址，然后连接到 server 的 443 端口 (HTTPS 默认端口）
* 采用 HTTPS 协议的服务器必须要有一套数字 CA (Certification Authority)证书
  `关于CA证书：需要申请需要钱；安全级别越高越贵`
* 服务器响应客户端请求，将证书传递给客户端
* 客户端解析证书并对其进行验证（是否属于可信机构&是否过期&证书中的域名与实际域名一致性）
* 证书无误：客户端就会从服务器证书中取出服务器的公钥A；生成一个随机码 KEY，并使用公钥A将其加密
* 客户端把加密后的随机码 KEY 发送给服务器，作为后面对称加密的密钥
* 服务器在收到随机码 KEY 之后会使用私钥B将其解密

**经过以上这些步骤，客户端和服务器终于建立了安全连接**

**2. 对称加密**
* 服务器使用密钥 (随机码 KEY)对数据进行对称加密并发送给客户端，客户端使用相同的密钥 (随机码 KEY)解密数据
* 双方使用对称加密愉快地传输所有数据

#### HTTPS加密速度

对称加密解密的速度比较快，适合数据比较长时的使用

非对称加密和解密花费的时间长、速度相对较慢，只适合对少量数据的使用

#### HTTPS的缺点
- 在相同网络环境中，HTTPS 相比 HTTP 无论是**响应时间**还是**耗电量**都有大幅度上升。
- **HTTPS 的安全是有范围的**，在黑客攻击、服务器劫持等情况下几乎起不到作用。
- 在现有的证书机制下，**中间人攻击**依然有可能发生。
- HTTPS 需要更多的服务器资源，也会导致**成本的升高**。

### HTTPS与HTTP

#### 区别
- 最最重要的区别就是**安全性**，HTTP 明文传输，不对数据进行加密安全性较差；HTTPS (HTTP + SSL / TLS)的数据传输过程是加密的，安全性较好
- 使用 HTTPS 协议需要申请 CA 证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、DigiCert 和 GlobalSign 等。
- **HTTP 页面响应速度比 HTTPS 快**，这个很好理解，由于加了一层安全层，建立连接的过程更复杂，也要交换更多的数据，难免影响速度。
- 由于 HTTPS 是建构在 SSL / TLS 之上的 HTTP 协议，所以，要比 HTTP 更耗费服务器资源。
- HTTPS 和 HTTP 使用的是完全不同的连接方式，用的端口也不一样，前者是 443，后者是 80

### 中间人攻击（MITM)

> 中间人攻击**MITM**（Man-in-the-middle Attack）多发生在未加密的通信中
> 比如 http 就是未加密的明文传输

**攻击方式**
* 攻击者插入自己作为通信方之间的“中间人”，以截取、篡改或窃取传输的数据
* 中间人截取的是`传输过程中的数据`，任何他觉得有用的数据都可以截取
* 中间人攻击并不仅仅发生在 HTTP 请求中，它可以发生在任何通过网络传输的通信中

中间人攻击并不仅限于非加密通信，`在加密通信中也会存在`，比如 https。` 只不过难度更大`

**常见形式**
1. 拦截和查看： 攻击者截取传输中的数据包，并查看其中的内容，可能包括敏感信息。
2. 篡改： 攻击者可能修改传输中的数据包，以执行恶意操作，如注入恶意代码或篡改页面内容。
3. 重放攻击： 攻击者可能记录先前的通信并重放其中的某些请求，以试图欺骗服务器或客户端。
4. SSL Stripping： 在HTTPS通信中，攻击者可能试图将连接转换为不安全的HTTP连接，从而绕过加密。【中间人和用户建立http 连接，中间人冒充用户与服务器建立https连接】

**防范措施**
- 使用 HTTPS： 对于敏感信息的传输，始终使用HTTPS，以确保通信是加密的。
- 使用可靠的证书： 在HTTPS 通信中，使用受信任的 SSL/TLS 证书，以确保通信的安全性。
- 安全的公共 Wi-Fi： 在使用公共 Wi-Fi 时，尽量避免访问敏感信息，因为这些网络可能容易受到中间人攻击。
- 强大的身份验证： 使用强大的身份验证机制，如多因素身份验证，以减少身份被盗用的风险。
- 持续监控和检测： 实施监控和检测机制，以及时发现并应对中间人攻击。

#### HTTP中间人攻击

在HTTP协议下，中间人攻击特别容易实施，因为：

- **明文传输**：HTTP所有数据都以明文形式传输
- **无身份验证**：无法验证服务器身份的真实性
- **无完整性保护**：数据容易被篡改
    

**攻击流程**：

1. 用户发起HTTP请求连接到目标网站
2. 攻击者通过ARP欺骗、DNS劫持等方式将自己置于用户与服务器之间
3. 攻击者可以：
    - 监听所有通信内容（账号密码、个人信息等）
    - 篡改网页内容（插入恶意代码、修改交易信息等）
    - 注入恶意脚本（如XSS攻击）

#### HTTPS中间人攻击

HTTPS通过TLS/SSL协议提供了加密和身份验证，大大提高了安全性，但在某些情况下仍可能遭受MITM攻击：

1. **证书欺骗**：
    - 攻击者使用自签名证书
    - 依赖于用户忽略浏览器证书警告
        
2. **SSL剥离(SSL Stripping)**：
    - 将HTTPS连接降级为HTTP
    - 常见于公共WiFi等不安全的网络环境
        
3. **CA证书被攻破**：
    - 攻击者控制或伪造受信任的CA证书
    - 如2011年DigiNotar事件
        
4. **协议漏洞利用**：
    - 利用TLS协议实现中的漏洞（如心脏出血漏洞）
    - 使用弱加密算法或过时的协议版本

**HTTPS防护机制：**

1. **加密传输**：使用对称加密保护数据内容
2. **身份验证**：通过数字证书验证服务器身份
3. **完整性保护**：防止数据在传输中被篡改
4. **HSTS机制**：强制使用HTTPS，防止SSL剥离

## XSS

> **XSS攻击介绍：** 攻击者通过在页面注入恶意脚本，使之在用户的浏览器上运行

### 原理

* XSS的本质是**"HTML注入"，攻击者将恶意脚本注入到可信的网站中，利用网站对用户输入的信任，在受害者的浏览器中执行恶意代码

### 攻击类型

**反射型XSS**
1. 非持久攻击
2. 恶意脚本来自当前HTTP请求
3. 通常需要诱骗`用户点击特制链接`

**存储型XSS**
- 持久化攻击
- 恶意脚本被存储在服务器上（数据库、文件等）
- 所有访问受影响页面的用户都会执行恶意代码
- 常见的攻击点
  1. 用户评论
  2. 论坛帖子
  3. 聊天信息

**DOM型XSS**
- 完全在客户端发生
- 不涉及服务器端处理
- 由不安全的DOM操作引起

### 防范

1）前端尽量对用户输入内容长度控制、输入内容限制（比如电话号码、邮箱、包括特殊字符的限制）

2）服务器对前端提交的内容`做好必要的转义`，`避免将恶意代码存储到数据库中`，造成存储性xss攻击

3）前端对服务器返回的数据做好必要的转义，保证显示到页面的内容正常

### VUE中如何防止XSS攻击

1）vue中使用`{{}}模板`渲染数据或通过v-bind给元素绑定属性时，都已将内容转义，防止xss攻击
2）尽量避免使用`v-html`，如果必须使用，可以使用`vue-xss`插件对文本内容进行转义，该插件可以同时去掉上面绑定的事件

## CSRF跨站请求伪造

### 概念

> CSRF（Cross Site Request Forgery） 跨站请求伪造
> 也被称为One Click Attack和Session Riding，通常缩写为CSRF或XSRF
> 
>可以这样理解：攻击者（黑客，钓鱼网站）盗用了你的身份，以你的名义发送恶意请求，这些请求包括`发送邮件、发送消息、盗取账号、购买商品、银行转账，从而使你的个人隐私泄露和财产损失`

### 原理

**要完成一次CSRF攻击 受害者必须完成以下步骤**
- 登录受信任网站A，并在本地生成Cookie。
- 在不登出A的情况下，访问危险网站B。

受害者在钓鱼网站中利用在被攻击网站已登录的凭证（凭证存在cookie中），冒充用户发送恶意请求
这些请求因为携带有用户的登录信息，`会被服务器当做正常的请求处理`，从而使个人隐私泄露或财产损失

### 防范

* 验证HTTP Referer字段
* 添加token验证
* 使用验证码
* 尽量属于POST 限制GET
* 在HTTP头部添加自定义属性

## 浏览器如何验证CA证书的有效性

浏览器读取证书中的**证书所有者、有效期等信息**进行校验

1）校验证书的网站域名是否与证书颁发的域名一致
2）校验证书是否在有效期内
3）浏览器查找操作系统中已内置的受信任的证书发布机构，与服务器发来的证书中的颁发者做比对，用于校验证书是否为合法机构颁发

## CSP

> 内容安全策略 CSP (Content Security Policy) 
> **CSP 防止 XSS 攻击， 浏览器自动禁止外部脚本注入**

**本质**
CSP 的实质就是白名单制度，开发者明确告诉客户端，哪些外部资源可以加载和执行，等同于提供白名单。它的实现和执行全部由浏览器完成，开发者只需提供配置

**优点**
CSP 大大增强了网页的安全性。攻击者即使发现了漏洞，也没法注入脚本，除非还控制了一台列入了白名单的可信主机





