
## JS的单线程

> js是单线程，只是说 **js的执行是单线程**的
> **但js的宿主环境**，无论是 Node 还是浏览器**都是多线程的**

以Chrome浏览器中为例，当你打开一个页面，其实就是创建了一个进程，一个进程中可以有多个线程，比如渲染线程、JS 引擎线程、HTTP 请求线程等等。 当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁。

**JS为什么设计成单线程？**

JavaScript的主要用途主要是用户互动，和操作DOM
线程之间`资源共享，相互影响`，如果JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时这两个节点会有很大冲突

`为了避免这个冲突，所以决定了它只能是单线程`，否则会带来很复杂的同步问题
此外HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程(GUI线程, 异步HTTP请求线程, 定时触发器线程...)，但是子线程完全受主线程控制，这个新标准并没有改变JavaScript单线程的本质

## 线程与进程

### 进程与线程的关系

* 进程是CPU分配的最小单位
* 而线程是进程调度的最小单位

**一个进程中至少有一个线程作为主线程**

### 浏览器的进程和线程

#### 浏览器的进程

> **一共有五个**

**1、浏览器进程（Browser进程）**  
浏览器的主进程，负责协调、主控，只有一个（无论打开几个tab或几个弹窗），主要作用：

- 负责浏览器界面显示，与用户交互，如前进，后退等；
- 负责各个页面的管理，创建和销毁其他进程；
- 将Renderer进程得到的内存中的Bitmap，绘制到用户界面上；
- 网络资源的管理，下载等；

**2、CPU进程**  
用于3D绘制等，可禁用掉，只有一个。

**3、第三方插件进程**  
每种类型的插件对应一个进程，仅当使用该插件时才创建。

**4、浏览器渲染进程**  
浏览器渲染进程（Renderer进程），即通常所说的浏览器内核，主要作用：页面渲染、脚本执行、事件处理等。每一个标签页的打开都会创建一个Renderer进程，且互不影响。默认一个标签页一个Renderer进程，但是，有时候浏览器会将多个进程合并（暂时没查到合并的依据），比如打开多个空白标签页：

**5、网络进程**
主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，后面独立出来，成为一个单独的进程

#### 浏览器的渲染进程

**1、GUI渲染线程**

- 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等；
- 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行；
- **注意：** GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。

**2、JS引擎线程**

- JS引擎线程也称为JS内核，负责处理Javascript脚本程序，解析Javascript脚本，运行代码；
- JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序；
- **注意：** GUI渲染线程与JS引擎线程的互斥关系，所以如果JS执行的时间过长，会造成页面的渲染不连贯，导致页面渲染加载阻塞。

**3、事件触发线程**

- 归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）；
- 当JS引擎执行代码块如setTimeOut时（也可是来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件触发线程中；
- 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理；
- **注意：** 由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）；

**4、定时器触发线程**

- 即setInterval与setTimeout所在线程；
- 浏览器定时计数器并不是由JS引擎计数的，因为JS引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确性；
- 因此使用单独线程来计时并触发定时器，计时完毕后，添加到事件队列中，等待JS引擎空闲后执行，所以定时器中的任务在设定的时间点不一定能够准时执行，定时器只是在指定时间点将任务添加到事件队列中；
- **注意：** W3C在HTML标准中规定，定时器的定时时间不能小于4ms，如果是小于4ms，则默认为4ms。

**5、异步http请求线程**

- XMLHttpRequest连接后通过浏览器新开一个线程请求；
- 检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将回调函数放入事件队列中，等待JS引擎空闲后执行；
    

#### 浏览器为什么是多进程

* 对于简单的网页，一个进程处理多个网页是可行的
* 但是把很多复杂的网页放进一个进程，浏览器面临`在健壮性，响应速度，安全性方面的挑战`。如果一个tab页崩溃，将导致同进程的其他页面崩溃，极其影响用户体验
* 另外进程之间是不共享资源和地址空间的,所以`不会存在太多的安全问题`
* 当然，多进程相对于单进程，内存等资源消耗更大，**有点空间换时间的意思**。这大概也是浏览器中存在多个tab页共用一个进程的情况的原因吧



## 浏览器页面渲染机制

**浏览器有GUI渲染线程与JS引擎线程，这两个线程是互斥的关系**

JavaScript的加载、解析与执行会阻塞DOM的构建。也就是说，在构建DOM时，HTML解析器若遇到了JavaScript，那么它会暂停构建DOM，将控制权移交给JavaScript引擎，等JavaScript引擎运行完毕，浏览器再从中断的地方恢复DOM构建

但是如果遇到带有async和defer的script标签，就会异步请求这些资源，不会阻塞页面渲染

浏览器渲染过程分为：构建DOM -> 构建CSSOM -> 构建渲染树 -> layout布局 -> 绘制

## DOM事件流

> DOM事件流，简单来说就是**事件执行顺序**

**事件类型**
DOM同时支持两种事件模型：捕获型事件流和冒泡型事件流

**DOM2事件流的三个阶段**
1）事件捕获阶段  
2）处于目标阶段  
3）事件冒泡阶段

**运用 -- 事件委托 -- addEventListener**

## 浏览器空闲时间

> 页面是一帧一帧绘制出来的，一般情况下，设备的屏幕刷新率为1s 60次，而当FPS小于60时，会出现一定程度的卡顿现象


**完整的一帧中具体做了哪些事情:**

1）首先需要处理输入事件，能够让用户得到最早的反馈
2）接下来是处理定时器，需要检查定时器是否到时间，并执行对应的回调
3）接下来处理 Begin Frame（开始帧），即每一帧的事件，包括 window.resize、scroll、media query change 等
4）接下来执行请求动画帧 requestAnimationFrame（rAF），即在每次绘制之前，会执行 rAF 回调
5）紧接着进行 Layout 操作，包括计算布局和更新布局，即这个元素的样式是怎样的，它应该在页面如何展示
6）接着进行 Paint 操作，得到树中每个节点的尺寸与位置等信息，浏览器针对每个元素进行内容填充

7）到这时以上的六个阶段都已经完成了，**接下来处于空闲阶段（Idle Peroid）**

## 垃圾回收机制

### GC垃圾回收机制

### V8优化 -- 分代式垃圾回收机制

V8采用了一种`代回收的策略`，将内存分为两个生代：新生代和老生代

* **新生代**中的对象为存活时间较短的对象
* **老生代**中的对象为存活时间较长或常驻内存的对象

对于新老两块内存区域的垃圾回收，V8 采用了两个垃圾回收器来管控，我们暂且将管理新生代的垃圾回收器叫做新生代垃圾回收器，同样的，我们称管理老生代的垃圾回收器叫做老生代垃圾回收器好了

#### 新生代垃圾回收

> 新生代对象是通过一个名为 `Scavenge` 的算法进行垃圾回收
> 在 `Scavenge算法` 的具体实现中，主要采用了一种复制式的方法即 `Cheney算法` ，我们细细道来


* 新加入的对象都会存放到使用区，`当使用区快被写满时`，就需要`执行一次垃圾清理操作`
* 当开始进行垃圾回收时，新生代垃圾回收器会对使用区中的活动对象做标记
  * 标记完成之后将使用区的活动对象`复制进空闲区并进行排序`
  * 随后进入垃圾清理阶段，即将`非活动对象占用的空间清理掉`
  * 最后进行角色互换，把原来的使用区变成空闲区，把原来的空闲区变成使用区

* 当一个对象经过多次复制后依然存活，它将会被认为是生命周期较长的对象，随后会被移动到老生代中，采用老生代的垃圾回收策略进行管理

* 另外还有一种情况，如果复制一个对象到空闲区时，空闲区空间占用超过了 25%，那么这个对象会被直接晋升到老生代空间中
* 设置为 25% 的比例的原因是，当完成 `Scavenge` 回收后，空闲区将翻转成使用区，继续进行对象内存的分配，若占比过大，将会影响后续内存分配

#### 老生代垃圾回收

* 相比于新生代，老生代的垃圾回收就比较容易理解了
* 因为老生代中的对象通常比较大，如果再如新生代一般分区然后复制来复制去就会非常耗时，从而导致回收执行效率不高，所以老生代垃圾回收器来管理其垃圾回收执行，**它的整个流程就采用的就是上文所说的标记清除算法了**

* 前面我们也提过，标记清除算法在清除后会产生大量不连续的内存碎片，过多的碎片会导致大对象无法分配到足够的连续内存，而 V8 中就采用了我们上文中说的标**记整理算法**来解决这一问题来优化空间

#### 为什么需要分代

分代式机制把一些新、小、存活时间短的对象作为新生代，采用一小块内存频率较高的快速清理
而一些大、老、存活时间长的对象作为老生代，使其很少接受检查

新老生代的回收机制及频率是不同的，可以说此机制的出现很大程度提高了垃圾回收机制的效率
